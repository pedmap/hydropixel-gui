# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Hidropixel
 Add the description
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-11-29
        git sha              : $Format:%H$
        copyright            : (C) 2023 by João Vitor & Adriano Rolim
        email                : jvds@academico.ufpb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt import uic
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon, QIntValidator, QDoubleValidator, QFont, QPixmap
from qgis.PyQt.QtWidgets import QApplication, QAction, QFileDialog, QMessageBox, QTableWidgetItem
from qgis.core import QgsProject, QgsMapLayer, QgsRasterLayer
import qgis.utils


# Import the code for the dialog
import os.path
import shutil
import os
import glob
from .hidroPixel_dialog import HidroPixelDialog
from pathlib import Path
from datetime import datetime
# A importação dos módulos contendo as variáveis
from hidropixel.modulos_files.RDC_variables import RDCVariables
from hidropixel.modulos_files.global_variables import GlobalVariables

# Initialize Qt resources from file resources.py
from .resources import *

# Importing libs
import numpy as np
import subprocess
from osgeo import ogr, gdal, gdalconst
from functools import wraps
import matplotlib.pyplot as plt
from collections import deque

class HidroPixel:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Hidropixel_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Hidropixel')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        # Criando instâncias das classes: apenas para inicalizar as variáveis que não são arrays. Estes dependem da dimensão do raster enviado
        self.global_vars = GlobalVariables(0, 0)
        self.rdc_vars = RDCVariables(0, 0)

        # Seleciona o diretório atual do plugin
        file_path = os.path.dirname(__file__)

        # Inicia a interface gráfica da rotina flow travel time
        ui_file = os.path.join(file_path, 'hidroPixel_dialog_flow_tt.ui')

        # Inicia a interface gráfica da rotina excess rainfall
        ui_file1 = os.path.join(
            file_path, 'hidroPixel_dialog_exec_rainfall.ui')

        # Inicia a interface gráfica da rotina flow routing
        ui_file2 = os.path.join(file_path, 'hidroPixel_dialog_flow_rout.ui')

        # Inicia a interface gráfica da pagina run da função rainfall interpolation
        ui_file3 = os.path.join(
            file_path, 'hidroPixel_dialog_run_rainfall_interpol.ui')

        # Inicia a interface gráfica da pagina run da função rainfall interpolation
        ui_file4 = os.path.join(
            file_path, 'hidropixel_dialog_about.ui')

        # Inicia interface para salvar o projeto
        ui_file5 = os.path.join(
            file_path, 'hidropixel_dialog_save_project_flow_tt.ui')

        # Inicia interface para salvar o projeto
        ui_file6 = os.path.join(
            file_path, 'hidropixel_dialog_save_project_flow_tt.ui')

        # Inicia interface para salvar o projeto
        ui_file7 = os.path.join(
            file_path, 'hidropixel_dialog_save_project_flow_tt.ui')

        # inicia instânica das diferentes routinas do plugin Hidropixel
        self.dlg_flow_tt = uic.loadUi(ui_file)
        self.dlg_exc_rain = uic.loadUi(ui_file1)
        self.dlg_flow_rout = uic.loadUi(ui_file2)
        self.dlg_rain_interpl_run = uic.loadUi(ui_file3)
        self.dlg_about = uic.loadUi(ui_file4)
        self.dlg_save_project_flow_tt = uic.loadUi(ui_file5)
        self.dlg_save_project_exc_rain = uic.loadUi(ui_file6)
        self.dlg_save_project_flow_rout = uic.loadUi(ui_file7)

        # Cria outras variáveis necessárias
        self.save_result = None
        self.fn_n_conect_dren = None
        self.fn_num_pix_dren = None
        self.fn_comp_acum = None
        self.fn_comp_foz = None
        self.fn_decli_pix = None
        self.fn_decli_pix_jus = None
        self.fn_temp_total = None
        self.fn_travel_time_map = None
        self.fn_hidrograma = None
        self.flag = None
        self.flag_1 = None
        self.alfa, self.delta_t, self.criterio_parada, self.beta = 0, 0, 0, 0
        self.numero_total_pix = 0
        self.num_intervalos = 0
        self.volume_total = 0.0
        self.quantidade_blocos_chuva = 0
        self.chuva_excedente_calc = 0
        self.blocos_vazao = 0
        self.Pexc = 0
        self.diretorio_atual = os.path.dirname(os.path.abspath(__file__))
        self.file_name_tb1: str = ''
        self.file_name_tb2: str = ''
        self.x_min = 0
        self.x_max = 0
        self.y_min = 0
        self.y_max = 0
        self.dx = 0
        self.dy = 0
        self.output1_flow_tt = ''
        self.output2_flow_tt = ''
        self.output3_flow_tt = ''
        self.output4_flow_tt = ''
        self.output5_flow_tt = ''
        self.output6_flow_tt = ''
        self.map_cond = 0
        self.output1_ri = ''
        self.output1_exec_rain = ''
        self.output2_exec_rain = ''
        self.output3_exec_rain = ''
        self.output4_exec_rain = ''
        self.output5_exec_rain = ''
        self.output6_exec_rain = ''
        self.output1_flow_rout = ''
        self.output2_flow_rout = ''
        self.output3_flow_rout = ''
        self.output4_flow_rout = ''
        self.output5_flow_rout = ''
        self.highlighted_style = "background-color: rgb(173, 216, 230)"
        self.lista_rasters_dir = [None]

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Hidropixel', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        # Armazena diretório do plugin
        icon_path = self.diretorio_atual + '\icons\icon3.png'

        self.add_action(
            icon_path,
            text=self.tr(u'Hidropixel Plugin'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = False

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Hidropixel'),
                action)
            self.iface.removeToolBarIcon(action)

    def carrega_work_folder(self, line_edit):
        '''Esta função define a pasta padrão tanto para buscar, quanto para salvar os arquivos'''
        # Define as variáveis e configurações da janela de escolha do arquivo
        pasta = None
        line_edit.setText('')
        options = QFileDialog.Options()
        pasta = QFileDialog.getExistingDirectory(
            None, caption='Select your working folder!', options=options)

        if pasta != '':
            # Se o usário enviar um arquivo, este será armazenado na sua referida line edit
            line_edit.setText(pasta)
        else:
            # Caso contrário, será mostrada uma mensagem de aviso
            result = "Wait! You did not select any folder."
            QMessageBox.warning(None, "No folder selected", result)

        return pasta

    def carregaArquivos(self, line_edit, combobox, file_type="raster"):
        """Esta função é utilizada para adicionar os arquivos enviados pelo usuário ao plugin"""
        # Define as variáveis e configurações da janela de escolha do arquivo
        file_ = None
        options = QFileDialog.Options()
        directory = self.dlg_flow_tt.le_21_pg1.text()

        while True:  # Loop até que o usuário selecione um arquivo ou cancele

            # Janela de diálogo com o Usuário
            if file_type == "raster":
                file_, _ = QFileDialog.getOpenFileName(
                    None, "Select a file!", directory, "GeoTIFF (*.tif)", options=options)
                if not file_:
                    QMessageBox.warning(
                        None, "No file selected", "Wait! You did not select any file.")
                    return None

                # Se o raster não estiver no projeto, adiciona
                if file_ not in [layer.source() for layer in QgsProject.instance().mapLayers().values()]:
                    layer = QgsRasterLayer(
                        file_, os.path.basename(file_), "gdal")
                    QgsProject.instance().addMapLayer(layer)

                # Recarrega os combos
                self.carrega_rasters()

                # Agora, seleciona no combo o novo raster
                nome = os.path.basename(file_)
                # Combobox guarda apenas nomes, então:
                idx = combobox.findText(nome)
                if idx != -1:
                    combobox.setCurrentIndex(idx)
                return file_

            elif file_type == "text".lower():
                file_, _ = QFileDialog.getOpenFileName(
                    None, caption="Select a file!", directory=directory, filter="Text Files (*.txt)", options=options)

                # Verificar se algum arquivo foi selecionado
                if file_:
                    line_edit.setText(file_)
                    break

                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(
                        None, "No file selected", result, QMessageBox.Ok)
                    if reply == QMessageBox.Ok:
                        break

    def save_buttons(self, line_edit, file_type='raster'):
        '''Esta função configura os botões da salvar (criar arquivo)'''
        # Seleciona o arquivo enviado pelo usuário
        while True:
            # Obtendo o caminho do arquivo a ser salvo usando um diálogo de arquivo
            if file_type == 'raster':
                file_name, _ = QFileDialog.getSaveFileName(
                    None, "Save the file", '', "GeoTIFF(*.tif)")
                if file_name:
                    line_edit.setText(file_name)
                    break
                else:
                    # O usuário não solucionou um arquivo (um caminho para salvar o arquivo de saída)
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(
                        None, "No file selected", result, QMessageBox.Ok)
                    if reply == QMessageBox.Ok:
                        break
            elif file_type == 'text':
                file_name, _ = QFileDialog.getSaveFileName(
                    None, "Save the file", '', "Text (*.txt)")
                if file_name:
                    line_edit.setText(file_name)
                    break
                else:
                    # O usuário não solucionou um arquivo (um caminho para salvar o arquivo de saída)
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(
                        None, "No file selected", result, QMessageBox.Ok)
                    if reply == QMessageBox.Ok:
                        break

    def selciona_pasta(self, line_edit):
        """Esta função solicita ao usuário a pasta para salvar os mapas da precipitação interpolada por cada delta_t"""
        while True:
            file_name = QFileDialog.getExistingDirectory(
                None, "Select a folder")
            if file_name:
                line_edit.setText(file_name)
                break
            else:
                # O usuário não solucionou um arquivo (um caminho para salvar o arquivo de saída)
                result = "Wait! You did not select any file."
                reply = QMessageBox.warning(
                    None, "No file selected", result, QMessageBox.Ok)
                if reply == QMessageBox.Ok:
                    break

    def save_to_project(self, function, file_name):
        """
        Gera um arquivo de texto único contendo todas as informações 
        apresentadas nas diferentes páginas do plugin.
        Function: Indica qual função a página pertence
            function == 1: Flow travel time;
            function == 2: Excess rainfall;
            function == 3: Flow routing
        """
        self.save_result = True
        with open(file_name, 'w', encoding='utf-8') as arquivo_txt:

            if function == 1:
                # Atribui nome do projeto a GUI
                self.dlg_flow_tt.le_12_pg2.setText(
                    self.dlg_save_project_flow_tt.le_1_pg1.text())
                self.dlg_flow_tt.le_1_pg3.setText(
                    self.dlg_save_project_flow_tt.le_1_pg1.text())
                self.dlg_flow_tt.le_12_pg4.setText(
                    self.dlg_save_project_flow_tt.le_1_pg1.text())

                # Seção: Flow Travel Time - Configuration (Página 1)

                arquivo_txt.write(
                    f"Project name: {self.dlg_save_project_flow_tt.le_1_pg1.text()}\n")

                arquivo_txt.write("Flow Travel Time - Configuration\n")
                arquivo_txt.write(
                    "-------------------------------------------------\n")
                arquivo_txt.write("GENERAL INFORMATIONS\n")
                arquivo_txt.write(
                    "Minimum slope surface travel time determination (m/km):\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.le_1_pg1.text()}\n")
                arquivo_txt.write(
                    "Orthogonal step for distance computation (dx):\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.le_3_pg1.text()}\n")
                arquivo_txt.write(
                    "Diagonal step for distance computation (dx):\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.le_4_pg1.text()}\n")
                arquivo_txt.write("Flow direction code:\n")
                arquivo_txt.write(
                    f"A = {self.dlg_flow_tt.le_5_pg1.text()}\n")
                arquivo_txt.write(
                    f"B = {self.dlg_flow_tt.le_6_pg1.text()}\n")
                arquivo_txt.write(
                    f"C = {self.dlg_flow_tt.le_7_pg1.text()}\n")
                arquivo_txt.write(
                    f"D = {self.dlg_flow_tt.le_8_pg1.text()}\n")
                arquivo_txt.write(
                    f"E = {self.dlg_flow_tt.le_9_pg1.text()}\n")
                arquivo_txt.write(
                    f"F = {self.dlg_flow_tt.le_10_pg1.text()}\n")
                arquivo_txt.write(
                    f"G = {self.dlg_flow_tt.le_11_pg1.text()}\n")
                arquivo_txt.write(
                    f"H = {self.dlg_flow_tt.le_12_pg1.text()}\n")
                arquivo_txt.write(
                    "CHANELS WITHOUT CROSS SECTIONAL AREA INFORMATIONS\n")
                arquivo_txt.write(
                    "Manning coefficient for river segments without cross-section information:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.le_14_pg1.text()}\n")
                arquivo_txt.write("Maximum river segment lenght (m):\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.le_15_pg1.text()}\n")
                arquivo_txt.write("Group Box is checked:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.groupBox_3.isChecked()}\n")
                arquivo_txt.write(
                    f"Coefficient c = {self.dlg_flow_tt.le_16_pg1.text()}\n")
                arquivo_txt.write(
                    f"Coefficient d = {self.dlg_flow_tt.le_17_pg1.text()}\n")
                arquivo_txt.write(
                    f"Coefficient g = {self.dlg_flow_tt.le_18_pg1.text()}\n")
                arquivo_txt.write(
                    f"Coefficient h = {self.dlg_flow_tt.le_19_pg1.text()}\n")
                arquivo_txt.write(
                    "lineage: Este arquivo foi criado automaticamente pelo Hidropixel\n")

                # Seção: Flow Travel Time - Input Data (Página 2)
                arquivo_txt.write("Flow Travel Time - Input Data\n")
                arquivo_txt.write(
                    "-------------------------------------------------\n")
                arquivo_txt.write("Watershed delineation:\n")
                arquivo_txt.write(
                    f"={self.lista_rasters_dir[self.dlg_flow_tt.cb_1_pg2.currentIndex()]}\n")
                arquivo_txt.write("\nDigital elevation model:\n")
                arquivo_txt.write(
                    f"={self.lista_rasters_dir[self.dlg_flow_tt.cb_2_pg2.currentIndex()]}\n")
                arquivo_txt.write("\nFlow direction:\n")
                arquivo_txt.write(
                    f"={self.lista_rasters_dir[self.dlg_flow_tt.cb_3_pg2.currentIndex()]}\n")
                arquivo_txt.write("\nRiver drainage network (RDN):\n")
                arquivo_txt.write(
                    f"={self.lista_rasters_dir[self.dlg_flow_tt.cb_4_pg2.currentIndex()]}\n")
                arquivo_txt.write("\nRDN segmentation into classes:\n")
                arquivo_txt.write(
                    f"={self.lista_rasters_dir[self.dlg_flow_tt.cb_5_pg2.currentIndex()]}\n")
                arquivo_txt.write("\nDrainage area (km²):\n")
                arquivo_txt.write(
                    f"={self.lista_rasters_dir[self.dlg_flow_tt.cb_6_pg2.currentIndex()]}\n")
                arquivo_txt.write("\nCharacteristics of RDN classes:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.le_8_pg2.text()}\n")
                arquivo_txt.write("\nLand use or land cover (LULC) map:\n")
                arquivo_txt.write(
                    f"={self.lista_rasters_dir[self.dlg_flow_tt.cb_7_pg2.currentIndex()]}\n")
                arquivo_txt.write(
                    "\nManning roughness coefficient for each LULC:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.le_10_pg2.text()}\n")
                arquivo_txt.write("\nRainfall depth for 24-h duration (mm):\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.le_11_pg2.text()}\n")

                # Seção: Flow Travel Time - Run page (Página 4)
                arquivo_txt.write("Flow Travel Time - Run page\n")
                arquivo_txt.write(
                    "-------------------------------------------------\n")
                arquivo_txt.write("Slope relative to downstream pixel:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.le_6_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_6_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_17_pg4.isChecked()}\n")
                arquivo_txt.write(
                    "All river segments with similar hydrologic conditions:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.le_7_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_7_pg4.isChecked()}\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_18_pg4.isChecked()}\n")
                arquivo_txt.write(
                    "Hydraulic radius, roughness and slope for all river segments:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.le_8_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_8_pg4.isChecked()}\n")
                arquivo_txt.write(
                    "River cross-sectional area calculated by regional curves (m²):\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.le_9_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_9_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_20_pg4.isChecked()}\n")
                arquivo_txt.write(
                    "River cross-sectional area calculated by regional curves (m):\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.le_10_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_10_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_21_pg4.isChecked()}\n")
                arquivo_txt.write("Flow travel time (min):\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.le_11_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_11_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_22_pg4.isChecked()}\n")

            if function == 2:
                # Define valor do projeto na GUI
                self.dlg_exc_rain.le_6_pg_ri.setText(
                    self.dlg_save_project_exc_rain.le_1_pg1.text())
                self.dlg_exc_rain.le_5_pg2.setText(
                    self.dlg_save_project_exc_rain.le_1_pg1.text())
                self.dlg_exc_rain.le_1_pg3.setText(
                    self.dlg_save_project_exc_rain.le_1_pg1.text())
                self.dlg_exc_rain.le_7_pg4.setText(
                    self.dlg_save_project_exc_rain.le_1_pg1.text())

                # Seção: Excess Rainfall - Configuration page (Função 2, Página 1)
                arquivo_txt.write(
                    f"Project name: {self.dlg_save_project_exc_rain.le_1_pg1.text()}\n")
                arquivo_txt.write("Excess Rainfall - Configuration page\n")
                arquivo_txt.write(
                    "-------------------------------------------------\n")
                arquivo_txt.write("Initial abstraction parameter (λ):\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.le_1_pg1.text()}\n")
                arquivo_txt.write("Rainfall definition:\n")
                arquivo_txt.write("    Areal averaged:\n")
                arquivo_txt.write(
                    f"   ={self.dlg_exc_rain.rb_1_pg1.isChecked()}\n")
                arquivo_txt.write("    Spatially distributed:\n")
                arquivo_txt.write(
                    f"   ={self.dlg_exc_rain.rb_2_pg1.isChecked()}\n")

                # Seção: Excess Rainfall - Rainfall interpolation (Função 2, Página 2)
                arquivo_txt.write("Excess Rainfall - Rainfall interpolation\n")
                arquivo_txt.write(
                    "-------------------------------------------------\n")
                arquivo_txt.write("Watershed delineation:\n")
                arquivo_txt.write(
                    f"={self.lista_rasters_dir[self.dlg_exc_rain.cb_1_pg_ri.currentIndex()]}\n")
                arquivo_txt.write("Rain gauges metadata:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.le_2_pg_ri.text()}\n")
                arquivo_txt.write("Rainfall data:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.le_3_pg_ri.text()}\n")
                arquivo_txt.write("\nRainfall file:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.le_4_pg_ri.text()}\n")
                arquivo_txt.write("Rainfall maps:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.le_5_pg_ri.text()}\n")

                # Seção: Excess Rainfall - Input Data (Função 2, Página 3)
                arquivo_txt.write("Excess Rainfall - Input Data\n")
                arquivo_txt.write(
                    "-------------------------------------------------\n")
                arquivo_txt.write("Watershed delineation:\n")
                arquivo_txt.write(
                    f"={self.lista_rasters_dir[self.dlg_exc_rain.cb_1_pg2.currentIndex()]}\n")
                arquivo_txt.write("Map of curve-number:\n")
                arquivo_txt.write(
                    f"={self.lista_rasters_dir[self.dlg_exc_rain.cb_2_pg2.currentIndex()]}\n")
                if self.dlg_exc_rain.rb_1_pg1.isChecked():
                    arquivo_txt.write("Areal averaged rainfall:\n")
                    arquivo_txt.write(
                        f"={self.dlg_exc_rain.le_3_pg2.text()}\n")
                else:
                    arquivo_txt.write(
                        "Spatially distributed rainfall:\n")
                    arquivo_txt.write(
                        f"={self.dlg_exc_rain.le_4_pg2.text()}\n")

                # Seção: Excess Rainfall - Run page (Função 2, Página 4)
                arquivo_txt.write("Excess Rainfall - Run page\n")
                arquivo_txt.write(
                    "-------------------------------------------------\n")
                arquivo_txt.write("Numbering of watershed pixels:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.le_1_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.ch_1_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.ch_7_pg4.isChecked()}\n")
                arquivo_txt.write("Maximum potential retention (mm):\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.le_2_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.ch_2_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.ch_8_pg4.isChecked()}\n")
                arquivo_txt.write("Initial abstraction (mm):\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.le_3_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.ch_3_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.ch_9_pg4.isChecked()}\n")
                arquivo_txt.write("Total rainfall (mm):\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.le_4_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.ch_4_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.ch_10_pg4.isChecked()}\n")
                arquivo_txt.write("Total excess rainfall (mm):\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.le_5_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.ch_5_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.ch_11_pg4.isChecked()}\n")
                arquivo_txt.write("Excess hyetographs per pixel (mm):\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.le_6_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.ch_6_pg4.isChecked()}\n")

            if function == 3:

                # Define valor do projeto na GUI

                self.dlg_flow_rout.le_6_pg2.setText(
                    self.dlg_save_project_flow_rout.le_1_pg1.text())

                self.dlg_flow_rout.le_1_pg3.setText(
                    self.dlg_save_project_flow_rout.le_1_pg1.text())

                self.dlg_flow_rout.le_8_pg4.setText(
                    self.dlg_save_project_flow_rout.le_1_pg1.text())

                # Seção: Flow Routing - Configuration page (Função 3, Página 1)
                arquivo_txt.write(
                    f"Project name: {self.dlg_save_project_flow_rout.le_1_pg1.text()}\n")
                arquivo_txt.write("Flow Routing - Configuration page\n")
                arquivo_txt.write(
                    "-------------------------------------------------\n")
                arquivo_txt.write("Model type:\n")
                arquivo_txt.write("    Hidropixel - TUH+:\n")
                arquivo_txt.write(
                    f"   ={self.dlg_flow_rout.rb_2_pg1.isChecked()}\n")
                arquivo_txt.write("    Hidropixel - DLR:\n")
                arquivo_txt.write(
                    f"   ={self.dlg_flow_rout.rb_3_pg1.isChecked()}\n")
                arquivo_txt.write("Parameter β:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.le_5_pg1.text()}\n")
                arquivo_txt.write("Time step (min):\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.le_2_pg1.text()}\n")

                # Seção: Flow Routing - Input Data page (Função 3, Página 2)
                arquivo_txt.write("Flow Routing - Input Data page\n")
                arquivo_txt.write(
                    "-------------------------------------------------\n")
                arquivo_txt.write("Watershed delineation:\n")
                arquivo_txt.write(
                    f"={self.lista_rasters_dir[self.dlg_flow_rout.cb_1_pg2.currentIndex()]}\n")
                arquivo_txt.write("Numbering of watershed pixels:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.cb_2_pg2.currentText()}\n")
                arquivo_txt.write("Flow travel time:\n")
                arquivo_txt.write(
                    f"={self.lista_rasters_dir[self.dlg_flow_rout.cb_3_pg2.currentIndex()]}\n")
                arquivo_txt.write("Excess hyetographs per pixel:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.le_4_pg2.text()}\n")
                arquivo_txt.write("Total excess rainfall per pixel (mm):\n")
                arquivo_txt.write(
                    f"={self.lista_rasters_dir[self.dlg_flow_rout.cb_5_pg2.currentIndex()]}\n")
                arquivo_txt.write(
                    "Hydrograph estimation for different watershed classes:\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.groupBox_2.isChecked()}\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.cb_4_pg2.currentText()}\n")

                # Seção: Flow Routing - Run page (Função 3, Página 4)
                arquivo_txt.write("Flow Routing - Run page\n")
                arquivo_txt.write(
                    "-------------------------------------------------\n")
                arquivo_txt.write("TUH peak discharge per pixel:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.le_1_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.ch_1_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.ch_7_pg4.isChecked()}\n")
                arquivo_txt.write("Select unit:\n")
                arquivo_txt.write("(L/s)\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.rb_1_pg4.isChecked()}\n")
                arquivo_txt.write("(m³/s)\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.rb_2_pg4.isChecked()}\n")
                arquivo_txt.write("TUH base time per pixel (min):\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.le_2_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.ch_2_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.ch_8_pg4.isChecked()}\n")
                arquivo_txt.write("Map of TUH base time (min):\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.le_3_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.ch_3_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.ch_9_pg4.isChecked()}\n")
                arquivo_txt.write("Resulting peak discharge per pixel:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.le_4_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.ch_4_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.ch_10_pg4.isChecked()}\n")
                arquivo_txt.write("Select unit:\n")
                arquivo_txt.write("(L/s)\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.rb_3_pg4.isChecked()}\n")
                arquivo_txt.write("(m³/s)\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.rb_4_pg4.isChecked()}\n")
                arquivo_txt.write("Resulting runoff volume per pixel (m³):\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.le_5_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.ch_5_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.ch_11_pg4.isChecked()}\n")
                arquivo_txt.write("Resulting watershed hydrograph (m³/s):\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.le_6_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.ch_6_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.ch_12_pg4.isChecked()}\n")
                if self.dlg_flow_rout.ch_12_pg4.isChecked():
                    arquivo_txt.write("Observed runoff (m³/s):\n")
                    arquivo_txt.write(
                        f"={self.dlg_flow_rout.le_7_pg4.text()}\n")

    def read_from_project(self, function, directory):
        '''Obtem as informações a partir projeto .hpx enviado pelo usuário
        Function: Indica qual função a página pertence
                function == 1: Flow travel time;
                function == 2: Excess rainfall;
                function == 3: Flow routing
        '''
        # Seleciona o arquivo enviado pelo usuário
        while True:
            options = QFileDialog.Options()
            file_, _ = QFileDialog.getOpenFileName(
                None, caption="Select a file!", directory=directory, filter="Hidropixel project (*.hpx)", options=options)

            if file_:
                if function == 1:
                    # Ler as informações da página 1: configuration
                    with open(file_, 'r', encoding='utf-8') as arquivo_txt:
                        # Armazena as informações do arquivo enviado em uma lista
                        cabecalho = arquivo_txt.readline().split(":")[1]
                        values = []
                        for line in arquivo_txt:
                            if '=' in line:
                                value_ = line.split("=")[1].strip()
                                values.append(value_)

                    # Adiciona as informações lidas nas suas respectivas
                    self.dlg_flow_tt.le_12_pg2.setText(
                        cabecalho)
                    self.dlg_flow_tt.le_1_pg3.setText(
                        cabecalho)
                    self.dlg_flow_tt.le_12_pg4.setText(
                        cabecalho)

                    # General informations
                    self.dlg_flow_tt.le_1_pg1.setText(str(values[0]))
                    self.dlg_flow_tt.le_3_pg1.setText(str(values[1]))
                    self.dlg_flow_tt.le_4_pg1.setText(str(values[2]))

                    # Flow dir
                    self.dlg_flow_tt.le_5_pg1.setText(str(values[3]))
                    self.dlg_flow_tt.le_6_pg1.setText(str(values[4]))
                    self.dlg_flow_tt.le_7_pg1.setText(str(values[5]))
                    self.dlg_flow_tt.le_8_pg1.setText(str(values[6]))
                    self.dlg_flow_tt.le_9_pg1.setText(str(values[7]))
                    self.dlg_flow_tt.le_10_pg1.setText(str(values[8]))
                    self.dlg_flow_tt.le_11_pg1.setText(str(values[9]))
                    self.dlg_flow_tt.le_12_pg1.setText(str(values[10]))

                    # River channels without cross sectional data
                    self.dlg_flow_tt.le_14_pg1.setText(str(values[11]))
                    self.dlg_flow_tt.le_15_pg1.setText(str(values[12]))

                    # Regional curve
                    self.dlg_flow_tt.groupBox_3.setChecked(
                        str(values[13]) == 'True')
                    self.dlg_flow_tt.le_16_pg1.setText(str(values[14]))
                    self.dlg_flow_tt.le_17_pg1.setText(str(values[15]))
                    self.dlg_flow_tt.le_18_pg1.setText(str(values[16]))
                    self.dlg_flow_tt.le_19_pg1.setText(str(values[17]))

                    # Input data

                    # Adiciona as informações lidas à seus respectivos campos
                    self.dlg_flow_tt.cb_1_pg2.setCurrentText(
                        os.path.basename(str(values[18])))
                    self.dlg_flow_tt.cb_2_pg2.setCurrentText(
                        os.path.basename(str(values[19])))
                    self.dlg_flow_tt.cb_3_pg2.setCurrentText(
                        os.path.basename(str(values[20])))
                    self.dlg_flow_tt.cb_4_pg2.setCurrentText(
                        os.path.basename(str(values[21])))
                    self.dlg_flow_tt.cb_5_pg2.setCurrentText(
                        os.path.basename(str(values[22])))
                    self.dlg_flow_tt.cb_6_pg2.setCurrentText(
                        os.path.basename(str(values[23])))

                    # Atribui os valores do arquivo enviado a tabela em questão
                    self.dlg_flow_tt.le_8_pg2.setText(str(values[24]))
                    self.read_tb_from_file_2(
                        self.dlg_flow_tt.tbw_1_pg2, values[24], 1, 2)

                    self.dlg_flow_tt.cb_7_pg2.setCurrentText(
                        os.path.basename(str(values[25])))

                    # Atribui os valores do arquivo enviado a tabela em questão
                    self.dlg_flow_tt.le_10_pg2.setText(str(values[26]))
                    self.read_tb_from_file_2(
                        self.dlg_flow_tt.tbw_2_pg2, values[26], 1, 1)

                    self.dlg_flow_tt.le_11_pg2.setText(str(values[27]))

                    # Ler arquivos página 4 - run
                    # Adiciona as informações lidas à seus respectivos campos
                    self.dlg_flow_tt.le_6_pg4.setText(str(values[28]))
                    self.dlg_flow_tt.ch_6_pg4.setChecked(
                        str(values[29]) == 'True')
                    self.dlg_flow_tt.ch_17_pg4.setChecked(
                        str(values[30]) == 'True')

                    self.dlg_flow_tt.le_7_pg4.setText(str(values[31]))
                    self.dlg_flow_tt.ch_7_pg4.setChecked(
                        str(values[32]) == 'True')
                    self.dlg_flow_tt.ch_18_pg4.setChecked(
                        str(values[33]) == 'True')

                    self.dlg_flow_tt.le_8_pg4.setText(str(values[34]))
                    self.dlg_flow_tt.ch_8_pg4.setChecked(
                        str(values[35]) == 'True')

                    self.dlg_flow_tt.le_9_pg4.setText(str(values[36]))
                    self.dlg_flow_tt.ch_9_pg4.setChecked(
                        str(values[37]) == 'True')
                    self.dlg_flow_tt.ch_20_pg4.setChecked(
                        str(values[38]) == 'True')

                    self.dlg_flow_tt.le_10_pg4.setText(str(values[39]))
                    self.dlg_flow_tt.ch_10_pg4.setChecked(
                        str(values[40]) == 'True')
                    self.dlg_flow_tt.ch_21_pg4.setChecked(
                        str(values[41]) == 'True')

                    self.dlg_flow_tt.le_11_pg4.setText(str(values[42]))
                    self.dlg_flow_tt.ch_11_pg4.setChecked(
                        str(values[43]) == 'True')
                    self.dlg_flow_tt.ch_22_pg4.setChecked(
                        str(values[44]) == 'True')
                    break

                elif function == 2:
                    # Lê os dados do arquivo e extrai as linhas que contenham o caractere "="
                    with open(file_, 'r', encoding='utf-8') as arquivo_txt:
                        cabecalho = arquivo_txt.readline().split(":")[1]
                        values = []
                        for line in arquivo_txt:
                            if '=' in line:
                                # Remove o caractere "=" e espaços em branco no início/fim da linha
                                value = line.replace('=', '').strip()
                                values.append(value)

                    self.dlg_exc_rain.le_6_pg_ri.setText(
                        cabecalho)
                    self.dlg_exc_rain.le_5_pg2.setText(
                        cabecalho)
                    self.dlg_exc_rain.le_1_pg3.setText(
                        cabecalho)
                    self.dlg_exc_rain.le_7_pg4.setText(
                        cabecalho)

                    # Seção: Excess Rainfall - Configuration page
                    self.dlg_exc_rain.le_1_pg1.setText(str(values[0]))
                    self.dlg_exc_rain.rb_1_pg1.setChecked(
                        str(values[1]) == 'True')
                    self.dlg_exc_rain.rb_2_pg1.setChecked(
                        str(values[2]) == 'True')

                    # Seção: Excess Rainfall - Rainfall interpolation
                    self.dlg_exc_rain.cb_1_pg_ri.setCurrentText(
                        os.path.basename(str(values[3])))
                    self.dlg_exc_rain.le_2_pg_ri.setText(
                        os.path.basename(str(values[4])))
                    self.dlg_exc_rain.le_3_pg_ri.setText(
                        os.path.basename(str(values[5])))
                    self.dlg_exc_rain.le_4_pg_ri.setText(
                        os.path.basename(str(values[6])))
                    self.dlg_exc_rain.le_5_pg_ri.setText(
                        os.path.basename(str(values[7])))

                    # Seção: Excess Rainfall - Input Data
                    self.dlg_exc_rain.cb_1_pg2.setCurrentText(
                        os.path.basename(str(values[8])))
                    self.dlg_exc_rain.cb_2_pg2.setCurrentText(
                        os.path.basename(str(values[9])))
                    # Se o rb_1_pg1 estiver marcado, usa um campo; senão, usa o outro
                    if self.dlg_exc_rain.rb_1_pg1.isChecked():
                        self.dlg_exc_rain.le_3_pg2.setText(str(values[10]))
                    else:
                        self.dlg_exc_rain.le_4_pg2.setText(str(values[10]))

                    # Seção: Excess Rainfall - Run page
                    self.dlg_exc_rain.le_1_pg4.setText(str(values[11]))
                    self.dlg_exc_rain.ch_1_pg4.setChecked(
                        str(values[12]) == 'True')
                    self.dlg_exc_rain.ch_7_pg4.setChecked(
                        str(values[13]) == 'True')

                    self.dlg_exc_rain.le_2_pg4.setText(str(values[14]))
                    self.dlg_exc_rain.ch_2_pg4.setChecked(
                        str(values[15]) == 'True')
                    self.dlg_exc_rain.ch_8_pg4.setChecked(
                        str(values[16]) == 'True')

                    self.dlg_exc_rain.le_3_pg4.setText(str(values[17]))
                    self.dlg_exc_rain.ch_3_pg4.setChecked(
                        str(values[18]) == 'True')
                    self.dlg_exc_rain.ch_9_pg4.setChecked(
                        str(values[19]) == 'True')

                    self.dlg_exc_rain.le_4_pg4.setText(str(values[20]))
                    self.dlg_exc_rain.ch_4_pg4.setChecked(
                        str(values[21]) == 'True')
                    self.dlg_exc_rain.ch_10_pg4.setChecked(
                        str(values[22]) == 'True')

                    self.dlg_exc_rain.le_5_pg4.setText(str(values[23]))
                    self.dlg_exc_rain.ch_5_pg4.setChecked(
                        str(values[24]) == 'True')
                    self.dlg_exc_rain.ch_11_pg4.setChecked(
                        str(values[25]) == 'True')

                    self.dlg_exc_rain.le_6_pg4.setText(str(values[26]))
                    self.dlg_exc_rain.ch_6_pg4.setChecked(
                        str(values[27]) == 'True')
                    break

                elif function == 3:
                    # Lê os arquivos da primeira página
                    with open(file_, 'r', encoding='utf-8') as arquivo_txt:
                        cabecalho = arquivo_txt.readline().split(":")[1]
                        # Armazenará os valores das linhas
                        values = []
                        for line in arquivo_txt:
                            if '=' in line:
                                # Substitui o identificador =por uma string fazia e retira os espaços da linha
                                value = line.replace('=', '').strip()
                                values.append(value)

                        self.dlg_flow_rout.le_6_pg2.setText(
                            cabecalho)

                        self.dlg_flow_rout.le_1_pg3.setText(
                            cabecalho)

                        self.dlg_flow_rout.le_8_pg4.setText(
                            cabecalho)

                    self.dlg_flow_rout.rb_2_pg1.setChecked(
                        str(values[0]) == 'True')
                    self.dlg_flow_rout.rb_3_pg1.setChecked(
                        str(values[1]) == 'True')
                    self.dlg_flow_rout.le_5_pg1.setText(str(values[2]))
                    self.dlg_flow_rout.le_2_pg1.setText(str(values[3]))

                    # Lê os arquivos da segunda página
                    self.dlg_flow_rout.cb_1_pg2.setCurrentText(
                        os.path.basename(str(values[4])))
                    self.dlg_flow_rout.cb_2_pg2.setCurrentText(
                        os.path.basename(str(values[5])))
                    self.dlg_flow_rout.cb_3_pg2.setCurrentText(
                        os.path.basename(str(values[6])))
                    self.dlg_flow_rout.le_4_pg2.setText(str(values[7]))
                    self.dlg_flow_rout.cb_5_pg2.setCurrentText(
                        os.path.basename(str(values[8])))
                    self.dlg_flow_rout.groupBox_2.setChecked(
                        str(values[9]) == "True")
                    self.dlg_flow_rout.cb_4_pg2.setCurrentText(
                        os.path.basename(str(values[10])))

                    # Lê os arquivos da quarta página

                    # Output1
                    self.dlg_flow_rout.le_1_pg4.setText(str(values[11]))
                    self.dlg_flow_rout.ch_1_pg4.setChecked(
                        str(values[12]) == 'True')
                    self.dlg_flow_rout.ch_7_pg4.setChecked(
                        str(values[13]) == 'True')
                    # Escolha da unidade (m³/a ou L/s)
                    self.dlg_flow_rout.rb_1_pg4.setChecked(
                        str(values[14]) == 'True')
                    self.dlg_flow_rout.rb_2_pg4.setChecked(
                        str(values[15]) == 'True')
                    # Output2
                    self.dlg_flow_rout.le_2_pg4.setText(str(values[16]))
                    self.dlg_flow_rout.ch_2_pg4.setChecked(
                        str(values[17]) == 'True')
                    self.dlg_flow_rout.ch_8_pg4.setChecked(
                        str(values[18]) == 'True')
                    # Output3
                    self.dlg_flow_rout.le_3_pg4.setText(str(values[19]))
                    self.dlg_flow_rout.ch_3_pg4.setChecked(
                        str(values[20]) == 'True')
                    self.dlg_flow_rout.ch_9_pg4.setChecked(
                        str(values[21]) == 'True')

                    # Output4
                    self.dlg_flow_rout.le_4_pg4.setText(str(values[22]))
                    self.dlg_flow_rout.ch_4_pg4.setChecked(
                        str(values[23]) == 'True')
                    self.dlg_flow_rout.ch_10_pg4.setChecked(
                        str(values[24]) == 'True')
                    # Escolha da unidade (m³/a ou L/s)
                    self.dlg_flow_rout.rb_3_pg4.setChecked(
                        bool(values[25]))
                    self.dlg_flow_rout.rb_4_pg4.setChecked(
                        bool(values[26]))
                    # Output5
                    self.dlg_flow_rout.le_5_pg4.setText(str(values[27]))
                    self.dlg_flow_rout.ch_5_pg4.setChecked(
                        str(values[28]) == 'True')
                    self.dlg_flow_rout.ch_11_pg4.setChecked(
                        str(values[29]) == 'True')
                    # Output6
                    self.dlg_flow_rout.le_6_pg4.setText(str(values[30]))
                    self.dlg_flow_rout.ch_6_pg4.setChecked(
                        str(values[31]) == 'True')
                    self.dlg_flow_rout.ch_12_pg4.setChecked(
                        str(values[32]) == 'True')

                    # hidrograma observado
                    if self.dlg_flow_rout.ch_12_pg4.isChecked():
                        self.dlg_flow_rout.le_7_pg4.setText(
                            str(values[33]))
                        break
            else:
                result = "Wait! You did not select any file."
                reply = QMessageBox.warning(
                    None, "No file selected", result, QMessageBox.Ok)
                if reply == QMessageBox.Ok:
                    break

    def save_table_to_file_btn(self, table):
        '''Esta função lê as informações adicionadas às tabelas e as armazena em um arquivo após o usuário clicar no botão de salvar
            table == 1: a tabela de referência é a tabelea das caracteristicas da rede de drenagem
            table == 2 referencia a tabela das classes e coeficientes de manning.'''
        while True:
            if table == 1:
                # Solicita um local de salvamento para o usuário
                file_name, _ = QFileDialog.getSaveFileName(
                    None, "Save the file", "RDN_classes", "Text (*.txt)")
                if file_name:
                    self.dlg_flow_tt.le_8_pg2.setText(file_name)
                    # seleciona as dimensões da tabela
                    nlin_tb1 = self.dlg_flow_tt.tbw_1_pg2.rowCount()
                    ncol_tb1 = self.dlg_flow_tt.tbw_1_pg2.columnCount()

                    # Escreve o arquivo de saída
                    with open(file_name, 'w', encoding='utf-8') as arquivo_txt_csv:
                        arquivo_txt_csv.write(f'Trecho,Rh (m),n,S (m/m)\n')
                        # Adicionando as informações das linhas e colunas ao arquivo de saída
                        for lin in range(nlin_tb1):
                            for col in range(ncol_tb1):
                                item = self.dlg_flow_tt.tbw_1_pg2.item(
                                    lin, col)
                                # Verifica se o item existe
                                if item is not None and item != '':
                                    if col != 3:
                                        arquivo_txt_csv.write(
                                            f'{item.text()},')
                                    else:
                                        arquivo_txt_csv.write(f'{item.text()}')
                            arquivo_txt_csv.write('\n')
                    break
                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(
                        None, "No file selected", result, QMessageBox.Ok)
                    if reply == QMessageBox.Ok:
                        break

            elif table == 2:
                file_name, _ = QFileDialog.getSaveFileName(
                    None, "Save the file", "Manning_roughness_coef_for_each_LULC", "Text (*.txt)")
                if file_name:
                    self.dlg_flow_tt.le_10_pg2.setText(file_name)
                    # seleciona as dimensões da tabela
                    nlin_tb1 = self.dlg_flow_tt.tbw_2_pg2.rowCount()
                    ncol_tb1 = self.dlg_flow_tt.tbw_2_pg2.columnCount()

                    # Escreve o arquivo de saída
                    with open(file_name, 'w', encoding='utf-8') as arquivo_txt_csv:
                        arquivo_txt_csv.write(
                            'Land Cover Type Code,Land Cover Type Name,Manning (Sheet Flow),Coefficient k (Shallow concentrated flow)\n')
                        # Adicionando as informações das linhas e colunas ao arquivo de saída
                        for lin in range(nlin_tb1):
                            for col in range(ncol_tb1):
                                item = self.dlg_flow_tt.tbw_2_pg2.item(
                                    lin, col)
                                # Verifica se o item existe
                                if item is not None and item != '':
                                    if col != 3:
                                        arquivo_txt_csv.write(
                                            f'{item.text()},')
                                    else:
                                        arquivo_txt_csv.write(f'{item.text()}')
                            arquivo_txt_csv.write('\n')
                    break
                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(
                        None, "No file selected", result, QMessageBox.Ok)
                    if reply == QMessageBox.Ok:
                        break

    def save_table_to_file(self, table):
        '''Esta função lê as informações adicionadas às tabelas e as armazena em um arquivo, sendo essas para leitura do visual basic
            table == 1: a tabela de referência é a tabelea das caracteristicas da rede de drenagem
            table == 2 referencia a tabela das classes e coeficientes de manning.'''

        if table == 1:
            # Solicita um local de salvamento para o usuário
            self.file_name_tb1 = self.diretorio_atual + \
                r'\temp' + r'\segment_characteristics.txt'
            if self.file_name_tb1:
                # seleciona as dimensões da tabela
                nlin_tb1 = self.dlg_flow_tt.tbw_1_pg2.rowCount()
                ncol_tb1 = self.dlg_flow_tt.tbw_1_pg2.columnCount()

                # Escreve o arquivo de saída
                with open(self.file_name_tb1, 'w', encoding='utf-8') as arquivo_txt_csv:
                    arquivo_txt_csv.write(f'Trecho,Rh (m),n,S (m/m)\n')
                    # Adicionando as informações das linhas e colunas ao arquivo de saída
                    for lin in range(nlin_tb1):
                        for col in range(ncol_tb1):
                            item = self.dlg_flow_tt.tbw_1_pg2.item(lin, col)
                            # Verifica se o item existe
                            if col <= 3:
                                if item is not None and item != '' and col < 3:
                                    arquivo_txt_csv.write(f'{item.text()},')
                                if col == 3:
                                    arquivo_txt_csv.write(f'{item.text()}')
                        arquivo_txt_csv.write('\n')

        elif table == 2:
            self.file_name_tb2 = self.diretorio_atual + r'\temp' + r'\surface_roughness.txt'
            if self.file_name_tb2:
                # seleciona as dimensões da tabela
                nlin_tb1 = self.dlg_flow_tt.tbw_2_pg2.rowCount()
                ncol_tb1 = self.dlg_flow_tt.tbw_2_pg2.columnCount()

                # Escreve o arquivo de saída
                with open(self.file_name_tb2, 'w', encoding='utf-8') as arquivo_txt_csv:
                    arquivo_txt_csv.write(
                        'Land Cover Type Code,Land Cover Type Name,Manning (Sheet Flow),Coefficient k (Shallow concentrated flow)\n')
                    # Adicionando as informações das linhas e colunas ao arquivo de saída
                    for lin in range(nlin_tb1):
                        for col in range(ncol_tb1):
                            item = self.dlg_flow_tt.tbw_2_pg2.item(lin, col)
                            if col <= 3:
                                # Verifica se o item existe
                                if item is not None and item != '' and col < 3:
                                    arquivo_txt_csv.write(f'{item.text()},')
                                if col == 3:
                                    arquivo_txt_csv.write(f'{item.text()}')
                        arquivo_txt_csv.write('\n')

    def read_tb_from_file(self, table, lineEdit, table_ordem):
        '''Esta função adiciona os valores do arquivo enviado pelo usuário à respectiva tabela
            table == 1: a tabela de referência é a tabelea das caracteristicas da rede de drenagem
            table == 2 referencia a tabela das classes e coeficientes de manning.'''

        # Seleciona o arquivo enviado pelo usuário
        options = QFileDialog.Options()
        directory = self.dlg_flow_tt.le_21_pg1.text()
        # Atualiza a flag para leitura dos dados da tabela
        self.flag = 1
        self.flag_1 = 1

        while True:
            # Solicita o arquivo
            file_, _ = QFileDialog.getOpenFileName(
                None, caption="Select a file!", directory=directory, filter="Text or CSV Files (*.txt *.csv)", options=options)

            if file_:
                # Configura a primeira tabela
                if table_ordem == 1:
                    lineEdit.setText(file_)
                    # Abre o arquivo e processa as linhas
                    with open(file_, 'r', encoding='utf-8') as arquivo_txt_csv:
                        # Lê a linha e o cabeçalho
                        arquivo_txt_csv.readline()

                        # Inicializa as listas para armazenamento das informações
                        id_class_list = []
                        Sclasse_list = []
                        Mannclasse_list = []
                        Rhclasse_list = []

                        # Iterando sobre as linhas do arquivo
                        for line in arquivo_txt_csv:
                            info = line.strip().split(',')
                            # Armazenando os valores das linhas nas suas respectivas variáveis
                            if info[0] != '' and info[1] != '' and info[2] != '' and info[3]:
                                indice = info[0]
                                Scla = info[1]
                                Mann = info[2]
                                Rh = info[3]
                                # Adiciona os valores às listas
                                id_class_list.append(indice)
                                Sclasse_list.append(Scla)
                                Mannclasse_list.append(Mann)
                                Rhclasse_list.append(Rh)

                    # Atualiza no número de linhas da tabela (recebe o número de classes dos rios da bacia hidrográfica)
                    table.setRowCount(len(Mannclasse_list))

                    # Coleta as dimensões da tabela
                    n_row = table.rowCount()
                    n_column = table.columnCount()

                    # Itera sobre os elementos da tabela
                    for lin in range(n_row):
                        for col in range(n_column):

                            if col == 0:
                                # Adiciona a coluna do id
                                item = QTableWidgetItem(
                                    str(int(id_class_list[lin])))
                                table.setItem(lin, col, item)
                            elif col == 1:
                                # Adiciona a coluna da declividade
                                item = QTableWidgetItem(str(Sclasse_list[lin]))
                                table.setItem(lin, col, item)
                            elif col == 2:
                                # Adiciona a coluna do coef de Manning
                                item = QTableWidgetItem(
                                    str(Mannclasse_list[lin]))
                                table.setItem(lin, col, item)
                            elif col == 3:
                                # Adiciona a coluna do raio hidráulico
                                item = QTableWidgetItem(
                                    str(Rhclasse_list[lin]))
                                table.setItem(lin, col, item)
                    break

                # Configura a segunda tabela
                else:

                    # Criando variável extra, para armazenar os tipos de uso e coeficente de Manning
                    lineEdit.setText(file_)
                    # Criando variável extra, para armazenar os tipos de uso e coeficente de Manning
                    class_id = 0
                    class_val = []
                    class_name_val = []
                    coef_maning = []
                    coef_K = []
                    uso_manning_val = {}
                    coef_maning_val = []
                    coef_K_val = []

                    # Abrindo o arquivo que contém o coeficiente de Manning para os diferentes usos do solo
                    with open(file_, 'r', encoding='utf-8') as arquivo_txt_csv:
                        # Amazena a linha do cabeçalho
                        firt_line = arquivo_txt_csv.readline().strip()

                        # Lê as informações de uso do solo e coeficiente de Manning
                        for line in arquivo_txt_csv:
                            # Coletando as informações de cada linha
                            info = line.strip().split(',')
                            # Armazenando os valores das linhas nas suas respectivas variáveis
                            if info[0] != '' and info[1] != '' and info[2] != '' and info[3]:
                                classe_id_key = int(info[0])
                                classe_name = str(info[1])
                                coef_maning = float(info[2])
                                coef_K = float(info[3])

                                # Adicionando os valores nas variáveis destinadas
                                coef_maning_val = np.append(
                                    coef_maning_val, coef_maning)
                                class_name_val = np.append(
                                    class_name_val, classe_name)
                                class_val = np.append(class_val, classe_id_key)
                                coef_K_val = np.append(coef_K_val, coef_K)
                                uso_manning_val[classe_id_key] = class_id
                                class_id += 1

                    # Atualiza no número de linhas da tabela (recebe o número de classes dos rios da bacia hidrográfica)
                    table.setRowCount(len(uso_manning_val))

                    # Coleta as dimensões da tabela
                    n_row = table.rowCount()
                    n_column = table.columnCount()

                    # Adiciona as informações à tabela
                    for col in range(n_column):
                        for lin in range(n_row):
                            if col == 0:
                                # Adiciona a coluna class Id
                                item = QTableWidgetItem(
                                    str(int(class_val[lin])))
                                table.setItem(lin, col, item)
                            elif col == 1:
                                # Adiciona a coluna class Name
                                item = QTableWidgetItem(
                                    str(class_name_val[lin]))
                                table.setItem(lin, col, item)
                            elif col == 2:
                                # Adiciona a coluna do coef de Manning
                                item = QTableWidgetItem(
                                    str(coef_maning_val[lin]))
                                table.setItem(lin, col, item)
                            elif col == 3:
                                # Adiciona a coluna do coef K (shallow concentreted flow)
                                item = QTableWidgetItem(str(coef_K_val[lin]))
                                table.setItem(lin, col, item)

                    break

            else:
                result = "Wait! You did not select any file."
                reply = QMessageBox.warning(
                    None, "No file selected", result, QMessageBox.Ok)
                if reply == QMessageBox.Ok:
                    break

    def read_tb_from_file_2(self, table, line_edit, table_ordem, tb2):
        '''Esta função adiciona os valores do arquivo enviado pelo usuário à tabela quando se clica no botão READ FROM FILE (da página 2)
            table == 1: a tabela de referência é a tabelea das caracteristicas da rede de drenagem
            table == 2: referencia a tabela das classes e coeficientes de manning. 
            '''
        # Atribui os valores do arquivo enviado à tabela das características
        file_ = str(line_edit)
        if table_ordem == 1:
            # Abre o arquivo e processa as linhas
            with open(file_, 'r', encoding='utf-8') as arquivo_txt_csv:
                # Lê a linha e o cabeçalho
                arquivo_txt_csv.readline()

                # Inicializa as listas para armazenamento das informações
                id_class_list = []
                Sclasse_list = []
                Mannclasse_list = []
                Rhclasse_list = []

                # Iterando sobre as linhas do arquivo
                for line in arquivo_txt_csv:
                    info = line.strip().split(',')
                    # Armazenando os valores das linhas nas suas respectivas variáveis
                    if info[0] != '' and info[1] != '' and info[2] != '' and info[3]:
                        if tb2 != 1:
                            indice = int(info[0])
                            Scla = float(info[1])
                            Mann = float(info[2])
                            Rh = float(info[3])

                        if tb2 == 1:
                            indice = int(info[0])
                            Scla = (info[1])
                            Mann = float(info[2])
                            Rh = float(info[3])

                        # Adiciona os valores às listas
                        id_class_list.append(indice)
                        Sclasse_list.append(Scla)
                        Mannclasse_list.append(Mann)
                        Rhclasse_list.append(Rh)

            # Atualiza no número de linhas da tabela (recebe o número de classes dos rios da bacia hidrográfica)
            table.setRowCount(len(Mannclasse_list))

            # Coleta as dimensões da tabela
            n_row = table.rowCount()
            n_column = table.columnCount()

            # Itera sobre os elementos da tabela
            for lin in range(n_row):
                for col in range(n_column):

                    if col == 0:
                        # Adiciona a coluna do id
                        item = QTableWidgetItem(str(int(id_class_list[lin])))
                        table.setItem(lin, col, item)
                    elif col == 1:
                        # Adiciona a coluna da declividade
                        item = QTableWidgetItem(str(Sclasse_list[lin]))
                        table.setItem(lin, col, item)
                    elif col == 2:
                        # Adiciona a coluna do coef de Manning
                        item = QTableWidgetItem(str(Mannclasse_list[lin]))
                        table.setItem(lin, col, item)
                    elif col == 3:
                        # Adiciona a coluna do raio hidráulico
                        item = QTableWidgetItem(str(Rhclasse_list[lin]))
                        table.setItem(lin, col, item)

        # Configura a segunda tabela
        else:
            # não sei o motivo de não ter funcionado para a segunda tabela. mas funcionou e deixei assim
            a = True

    def leh_geotiff_escreve_ascii(self, arquivo, arquivo2, int_float, mapa_classes='n'):
        '''Esta função realiza a leitura do arquivo .tif enviado pelo user e o converte em .rst tipo ascii para leitura no visual basic
            arquivo1 = diretório do arquivo arquivo raster tiff
            arquivo2 = arquivo raster tipo rst ascii (será criado)'''

        # Lê o arquivo .tiff enviado
        raster_enviado = gdal.Open(arquivo)

        # Lendo os dados raster como um array
        dados_lidos = raster_enviado.GetRasterBand(1).ReadAsArray()

        # Tratamento de erro: verifica se o arquivo foi aberto corretamente
        if raster_enviado is not None:
            # Obtenção da dimensão da imagem raster
            self.rdc_vars.nlin = raster_enviado.RasterYSize
            self.rdc_vars.ncol = raster_enviado.RasterXSize
            self.rdc_vars.geotransform = raster_enviado.GetGeoTransform()
            self.rdc_vars.projection = raster_enviado.GetProjection()

            self.rdc_vars.resolucao = self.rdc_vars.geotransform[1]

            # Coordenadas da célula lin = 0, col = 0
            self.x_min = self.rdc_vars.geotransform[0]
            self.y_max = self.rdc_vars.geotransform[3]

            # Captura resoluções espaciais da imagem (sentido vertical e horizontal)
            self.dx = self.rdc_vars.geotransform[1]
            self.dy = self.rdc_vars.geotransform[5]

            # Coordenadas do canto inferior direito
            self.x_max = self.x_min + (self.rdc_vars.ncol * self.dx)
            self.y_min = self.y_max + (self.rdc_vars.nlin * self.dy)

        # Leitura do arquivo ascii
        if int_float == 'int':
            with open(arquivo2, 'w') as arquivo_ascii:
                for lin in range(0, self.rdc_vars.nlin):
                    for col in range(0, self.rdc_vars.ncol):
                        arquivo_ascii.write(
                            f'{str(int(dados_lidos[lin,col]))}\n')

        elif int_float == 'float':
            with open(arquivo2, 'w') as arquivo_ascii:
                for lin in range(self.rdc_vars.nlin):
                    for col in range(self.rdc_vars.ncol):
                        arquivo_ascii.write(
                            f'{str(float(dados_lidos[lin,col]))}\n')

        arquivo2_doc = arquivo2.replace('.rst', '.rdc')
        with open(arquivo2_doc, 'w', encoding='utf-8') as arquivo_rdc:
            arquivo_rdc.write('Raster Informations\n')
            arquivo_rdc.write(f'Rows,{self.rdc_vars.nlin}\n')
            arquivo_rdc.write(f'Columns,{self.rdc_vars.ncol}\n')
            arquivo_rdc.write(
                f'resolution,{np.abs(self.rdc_vars.resolucao)}\n')
            arquivo_rdc.write(f'resolution (X),{self.dx}\n')
            arquivo_rdc.write(f'resolution (Y),{self.dy}\n')
            arquivo_rdc.write(f'Min_X,{self.x_min}\n')
            arquivo_rdc.write(f'Max_X,{self.x_max}\n')
            arquivo_rdc.write(f'Min_Y,{self.y_min}\n')
            arquivo_rdc.write(f'Max_Y,{self.y_max}\n')
            if mapa_classes == 'y':
                # Determina quantidade de classes
                qtd_classes = len(np.unique(dados_lidos[dados_lidos != 0]))
                arquivo_rdc.write(f'watershed_classes,{qtd_classes}\n')

    def leh_rst_escreve_geotiff(self, arquivo1, arquivo2, file_type):
        '''Esta função lê os arquivos processados nas rotinas em visual basic, no formato .rst(ascii) e os escreve em geotiff (no diretório informado)
            arquivo1 = diretório do arquivo raster tipo rst ascii
            arquivo2 = arquivo raster tiff (será criado)'''

        # Convertendo arquivo ascii para geotiff
        rst_to_raster = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))

        # Leitura do arquivo ascii
        if file_type == 'int':
            with open(arquivo1, 'r') as arquivo_ascii:
                for lin in range(self.rdc_vars.nlin):
                    for col in range(self.rdc_vars.ncol):
                        rst_to_raster[lin, col] = int(arquivo_ascii.readline())

        elif file_type == 'float':
            with open(arquivo1, 'r') as arquivo_ascii:
                for lin in range(self.rdc_vars.nlin):
                    for col in range(self.rdc_vars.ncol):
                        rst_to_raster[lin, col] = float(
                            arquivo_ascii.readline())

        # Define os dados a serem escritos
        if file_type == 'int':
            tipo_dados = gdalconst.GDT_Int32
        elif file_type == 'float':
            tipo_dados = gdalconst.GDT_Float32

        # Obtendo o driver para escrita do arquivo em GeoTiff
        fn_geotiff = arquivo2
        driver = gdal.GetDriverByName('GTiff')

        # Cria arquivo final
        dataset = driver.Create(
            fn_geotiff, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)
        dataset.SetGeoTransform(self.rdc_vars.geotransform)
        dataset.SetProjection(self.rdc_vars.projection)

        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(rst_to_raster)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None
        tipo_dados = None

    def leh_asc_escreve_geotiff(self, arquivo1):
        '''Esta função lê os arquivos processados nas rotinas em visual basic, no formato .rst(ascii) e os escreve em geotiff (no diretório informado)
            arquivo1 = diretório do arquivo raster tipo rst ascii
            arquivo2 = arquivo raster tiff (será criado)'''
        # Modifica extensão do arquivo de saída para tif
        arquivo_atual = os.path.basename(arquivo1)
        arquivo_atual_tif = arquivo_atual.replace('.asc', '.tif')
        arquivo2 = os.path.join(
            self.dlg_exc_rain.le_5_pg_ri.text(), arquivo_atual_tif)

        # Convertendo arquivo ascii para geotiff
        rst_to_raster = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        bobo = [0 for x in range(6)]
        # Leitura do arquivo ascii
        with open(arquivo1, 'r') as arquivo_ascii:
            for i in range(6):
                bobo[i] = arquivo_ascii.readline()
            for lin in range(self.rdc_vars.nlin):
                for col in range(self.rdc_vars.ncol):
                    rst_to_raster[lin, col] = float(arquivo_ascii.readline())

        # Define os dados a serem escritos
        tipo_dados = gdalconst.GDT_Float32

        # Obtendo o driver para escrita do arquivo em GeoTiff
        fn_geotiff = arquivo2
        driver = gdal.GetDriverByName('GTiff')

        # Cria arquivo final
        dataset = driver.Create(
            fn_geotiff, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)
        dataset.SetGeoTransform(self.rdc_vars.geotransform)
        dataset.SetProjection(self.rdc_vars.projection)

        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(rst_to_raster)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None
        tipo_dados = None

    def add_new_row(self, table):
        '''Está função adiciona uma linha a uma tabela relecionada'''
        last_row = table.rowCount()
        table.insertRow(last_row)

    def delete_row(self, table):
        '''Esta função deleta uma linha de uma referida tabela'''
        selected_row = table.currentRow()
        if selected_row >= 0:
            table.removeRow(selected_row)
        else:
            QMessageBox.warning(None, "Warning", "You did not select any row.")

    def close_gui(self, function):
        '''Está função é usada para torna nulo (limpar) as informações adicionadas nos diferentes objetos das funções do Hidropixel Plugin
           - Function = 1 : Flow travel time
           - Function = 2 : Excess rainfall
           - Function = 3 : Flow routing'''

        if function == 1:
            self.dlg_flow_tt.close()
            self.save_result = False

        elif function == 2:
            self.save_result = False
            self.dlg_exc_rain.close()

        elif function == 3:
            self.save_result = False
            self.dlg_flow_rout.close()

    def clear_table(self, table, lineEdit):
        '''Esta função limpa os valores armazenados na respectiva tabela'''
        # Limpando as informações armazenadas: tables widgets
        nlin_tb1 = table.rowCount()
        ncol_tb1 = table.columnCount()

        # Reinicia a respectiva tabela
        for lin in range(nlin_tb1):
            for col in range(ncol_tb1):
                item = table.item(lin, col)
                if item is not None:
                    item.setText('')
        # Limpa a lineEdit
        lineEdit.clear()

    def adiciona_layer(self, file_path):
        '''Esta função adiciona um arquivo enviado às layers do atual projeto do usuário no QGIS'''
        # Adiciona o arquivo raster ao projeto do QGIS
        file_name = os.path.basename(file_path)
        layer = QgsRasterLayer(file_path, 'gdal')
        layer.setName(file_name)
        QgsProject.instance().addMapLayer(layer)

        # Atualiza a tela do QGIS
        self.iface.layerTreeView().refreshLayerSymbology(layer.id())

    def reginal_curve_condition(self):
        """Define estado dos outputs que depende do metodo das curvas regionais"""

        if self.dlg_flow_tt.groupBox_3.isChecked() == True:
            # River cros-sectional area
            self.dlg_flow_tt.ch_9_pg4.setEnabled(True)
            self.dlg_flow_tt.label_87.setEnabled(True)
            self.dlg_flow_tt.le_9_pg4.setEnabled(True)
            self.dlg_flow_tt.ch_20_pg4.setEnabled(True)
            self.dlg_flow_tt.tbtn_pg4_9.setEnabled(True)
            self.dlg_flow_tt.label_86.setEnabled(True)

            # River bankfull width
            self.dlg_flow_tt.ch_10_pg4.setEnabled(True)
            self.dlg_flow_tt.label_89.setEnabled(True)
            self.dlg_flow_tt.le_10_pg4.setEnabled(True)
            self.dlg_flow_tt.tbtn_pg4_10.setEnabled(True)
            self.dlg_flow_tt.label_88.setEnabled(True)
            self.dlg_flow_tt.ch_21_pg4.setEnabled(True)

        else:
            # River cros-sectional area
            self.dlg_flow_tt.ch_9_pg4.setEnabled(False)
            self.dlg_flow_tt.label_87.setEnabled(False)
            self.dlg_flow_tt.le_9_pg4.setEnabled(False)
            self.dlg_flow_tt.ch_20_pg4.setEnabled(False)
            self.dlg_flow_tt.tbtn_pg4_9.setEnabled(False)
            self.dlg_flow_tt.label_86.setEnabled(False)

            # River bankfull width
            self.dlg_flow_tt.ch_10_pg4.setEnabled(False)
            self.dlg_flow_tt.label_89.setEnabled(False)
            self.dlg_flow_tt.le_10_pg4.setEnabled(False)
            self.dlg_flow_tt.tbtn_pg4_10.setEnabled(False)
            self.dlg_flow_tt.label_88.setEnabled(False)
            self.dlg_flow_tt.ch_21_pg4.setEnabled(False)

    def rain_def_condition(self, rain_condition):
        '''Esta função verifica a condição da variável precipitação para execução da rotina Excess rainfall
           - rain_condition == 1 : areal averaged
           - rain_condition == 2 : spatiallu distributed'''

        if rain_condition == 1:
            # Objetos ligado a opção de precipitação média na área da baica ficam ativos
            self.dlg_exc_rain.le_3_pg2.setEnabled(True)
            self.dlg_exc_rain.label_31.setEnabled(True)
            self.dlg_exc_rain.tbtn_pg2_3.setEnabled(True)
            self.dlg_exc_rain.label_35.setEnabled(True)

            # Objetos ligado a opção de precipitação distribuida espacialmente ficam inativos
            self.dlg_exc_rain.le_4_pg2.setEnabled(False)
            self.dlg_exc_rain.label_32.setEnabled(False)
            self.dlg_exc_rain.tbtn_pg2_4.setEnabled(False)
            self.dlg_exc_rain.label_36.setEnabled(False)

        elif rain_condition == 2:
            # Objetos ligado a opção de precipitação distribuida espacialmente ficam ativos
            self.dlg_exc_rain.le_4_pg2.setEnabled(True)
            self.dlg_exc_rain.label_32.setEnabled(True)
            self.dlg_exc_rain.tbtn_pg2_4.setEnabled(True)
            self.dlg_exc_rain.label_36.setEnabled(True)

            # Objetos ligado a opção de precipitação média na área da baica ficam inativos
            self.dlg_exc_rain.le_3_pg2.setEnabled(False)
            self.dlg_exc_rain.label_31.setEnabled(False)
            self.dlg_exc_rain.tbtn_pg2_3.setEnabled(False)
            self.dlg_exc_rain.label_35.setEnabled(False)

    def cancel_log_page(self, text_edit, pg_parameters, pg_logge):
        '''Esta função configura o botão de cancelar da página de log'''
        mensagem_log1 = None
        # Cria texto formatado para adicionar ao text edit? mensagem de aviso
        mensagem_log1 = '<font>\nATTENTION: stopping FLOW TRAVEL TIME process...</font>'

        # Adiciona o texto formatado no QTextEdit
        text_edit.insertHtml(mensagem_log1)

        # Reativa a página de parametros
        pg_parameters.setEnabled(True)

        # Desativa a página de logge
        pg_logge.setEnabled(False)

    def cancel_rainfall_interpol(self):
        '''Esta configura o botão cancel da página run da função rainfall interpolation'''
        # Adiciona mensagem de cancelamento do processo
        self.dlg_rain_interpl_run.te_rain_int(
            'BREAKING THE RAINFALL INTERPOLATION PROCESSING...')
        self.dlg_rain_interpl_run.close()

    def apaga_arquivos_temp(self):
        '''Esta função exclui os arquivos temporários criados durante a execução do plugin'''
        # Muda para o diretório temp
        os.chdir(self.diretorio_atual + r'\temp')
        # Obtém todos os arquivos com a extensão .txt, .rst, .rdc
        arquivos_txt = glob.glob('*.txt')
        arquivos_rst = glob.glob('*.rst')
        arquivos_rdc = glob.glob('*.rdc')

        # Apaga todos os arquivos .txt
        for txt in arquivos_txt:
            os.remove(txt)

        for rst in arquivos_rst:
            os.remove(rst)

        for rdc in arquivos_rdc:
            os.remove(rdc)

    def replace_tif_rst(self, arquivo1):
        '''Esta função modifica a extensão do parâmetro de .tif para .rst'''
        arquivo2 = arquivo1.replace('.tif', '.rst')
        return arquivo2

    def run_process_rainfall_interpol(self):
        """Esta função configura a execução da rotina Rainfall Interpolation do vb.net, gerando os arquivos necessários à execução daquela"""
        # Captura diretório dos arquivo txt (pasta temp)
        direct_temp = self.diretorio_atual + r'\temp'

        # Chama funções para tranformação do raster em geotiff para rst tipo ascii
        bacia_file = direct_temp + r'\Watershed.rst'
        self.leh_geotiff_escreve_ascii(
            self.dlg_exc_rain.cb_1_pg_ri.currentText(), bacia_file, 'int')

        # Cria uma cópia dos arquivos para a pasta temp: evita erros relacionados aos caracteries especiais
        rain_gauges = direct_temp + r'\rain_gauges.txt'
        shutil.copy(self.dlg_exc_rain.le_2_pg_ri.text(), rain_gauges)

        rainfall_data = direct_temp + r'\rainfall_data.txt'
        shutil.copy(self.dlg_exc_rain.le_3_pg_ri.text(), rainfall_data)

        # Escreve arquivo txt com os diretórios e nome dos inputs enviados pelo user
        direct_in_files = direct_temp + r'\input_files_config_rain_inte.txt'
        with open(direct_in_files, 'w', encoding='utf-8') as arquivo_txt:
            # Escreve cabeçalho
            arquivo_txt.write("Selected input file directory\n")
            arquivo_txt.write(f"watershed,{bacia_file}\n")
            arquivo_txt.write(f"rain_gauges,{rain_gauges}\n")
            arquivo_txt.write(f"rainfall_data,{rainfall_data}\n")
            arquivo_txt.write(f"map_condiction,{self.map_cond}")

        # Organiza os caminhos dos arquivos de saída enviados pelo user: modifica a extensão de .tif para .rst
        self.output1_ri = direct_temp + r'\rainfall_interpolated.txt'
        map_output_path = direct_temp + r'\maps'

        # Escreve aquivo txt contendo o diretório informado pelo user: será fornecido para a rotina em visual basic
        direct_out_files = direct_temp + r'\output_files_config_rain_inte.txt'
        with open(direct_out_files, 'w', encoding='utf-8') as arquivo_txt:
            arquivo_txt.write("Select output file directory\n")
            arquivo_txt.write(
                f"rainfall_interpolated_file,{self.output1_ri}\n")
            arquivo_txt.write(
                f"rainfall_interpolated_maps_path,{map_output_path}")

    def run_rainfall_interpolation(self, condicao):
        """Esta estrutura a ordem de execução da rontina que gera a chuva interpolada por pixel da bacia hidrográfica"""
        self.map_cond = condicao
        self.run_process_rainfall_interpol()
        # Chama executável vb para iniciar o processamento
        rainfall_interpol_vb = self.diretorio_atual + r'\temp\Rainfall_Interpolation.exe'
        rainfall_iterp_exe = subprocess.run([rainfall_interpol_vb])

        # verifica se houve algum erro no processamento das rotinas no vb ou se o usuario clicou em cancelar
        # Caso não, a execução continua no python
        if rainfall_iterp_exe.returncode == 0:

            # Se o usuário escolheu a opção para gerar o arquivo da chuva interpolada em txt, ele será salvo no caminho fornecido
            if self.map_cond == 0:
                os.rename(self.output1_ri, self.dlg_exc_rain.le_4_pg_ri.text())

            # Se o usuário escolheu para gerar os mapas da precipitação interpolada, eles serão enviados para a pasta informada
            else:
                # Captura os arquivos da pasta map
                os.chdir(self.diretorio_atual + r'\temp\maps')
                lista_mapas = glob.glob('*.asc')
                for mapa in lista_mapas:
                    self.leh_asc_escreve_geotiff(mapa)

            QMessageBox.information(
                None, "Information", "Operation completed successfully!", )

        else:
            QMessageBox.information(
                None, "Information", "There was an inconsistency, please verify if all files were sent!", )

    def processa_arquivo_chuva_med(self, input_file, output_file):
        # Lê todo o conteúdo do arquivo
        with open(input_file, 'r', encoding='utf-8') as f:
            linhas = f.readlines()

        # Verifica se o arquivo não está vazio
        if not linhas:
            raise Exception("Arquivo vazio!")

        # A primeira linha é o cabeçalho
        cabecalho = linhas[0].strip()

        # Linhas de dados (excluindo o cabeçalho)
        dados = [linha.strip() for linha in linhas[1:] if linha.strip()]

        # Número de linhas de dados
        num_linhas = len(dados)

        # Calcula o delta_t a partir das duas primeiras linhas de dados
        # Supondo que o arquivo esteja formatado como "Time(min),Rainfall(mm)"
        if num_linhas >= 2:
            primeiro_valor = float(dados[0].split(',')[0])
            segundo_valor = float(dados[1].split(',')[0])
            delta_t = segundo_valor - primeiro_valor
        else:
            delta_t = 0  # ou lança exceção, caso seja necessário

        # Escreve o novo arquivo com a primeira linha contendo "num_linhas,delta_t"
        with open(output_file, 'w', encoding='utf-8') as f_out:
            f_out.write(f"{num_linhas},{int(delta_t)}\n")
            f_out.write(cabecalho + "\n")
            for linha in dados:
                f_out.write(linha + "\n")

    def run_process_excess_rainfall(self):
        """Esta função organiza os arquivos enviados pelo user e os configura para serem lidos nas rotinas em visual basic"""
        # Captura diretório dos arquivo txt (pasta temp)
        direct_temp = self.diretorio_atual + r'\temp'

        # Chama funções para tranformação do raster em geotiff para rst tipo ascii

        # leh bacia tif gera bacia rst ascii
        bacia_file = direct_temp + r'\Watershed.rst'
        self.leh_geotiff_escreve_ascii(
            self.lista_rasters_dir[self.dlg_exc_rain.cb_1_pg2.currentIndex()], bacia_file, 'int')

        # leh cn map tif gera cn map rst ascii
        cn_file = direct_temp + r'\CN_map.rst'
        self.leh_geotiff_escreve_ascii(
            self.lista_rasters_dir[self.dlg_exc_rain.cb_2_pg2.currentIndex()], cn_file, 'int')

        # move arquivo da precipitação para a pasta temp
        if self.dlg_exc_rain.rb_1_pg1.isChecked():
            chuva_media = direct_temp + r'\Areal_averaged_rainfall.txt'
            self.processa_arquivo_chuva_med(
                self.dlg_exc_rain.le_3_pg2.text(), chuva_media)

        if self.dlg_exc_rain.rb_2_pg1.isChecked():
            chuva_distribuida = direct_temp + r'\Spatially_distributed_rainfall.txt'
            shutil.copy(self.dlg_exc_rain.le_4_pg2.text(), chuva_distribuida)

        # Escreve arquivos de parâmetros
        direct_parameters = direct_temp + r'\parameters_exc_rainf.txt'
        with open(direct_parameters, 'w', encoding='utf-8') as arquivo_txt:
            arquivo_txt.write(
                f"Initial abstraction (λ),{self.dlg_exc_rain.le_1_pg1.text()}")

        # gera arquivo contendo os diretórios dos inputs
        direct_in_files = direct_temp + r'\input_files_config_exc_rainf.txt'
        with open(direct_in_files, 'w', encoding='utf-8') as arquivo_txt:
            # Escreve cabeçalho
            arquivo_txt.write("Selected input file directory\n")
            arquivo_txt.write(
                f'{1 if self.dlg_exc_rain.cb_1_pg2.currentText() !="" else 0},watershed,{bacia_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_exc_rain.cb_2_pg2.currentText() !="" else 0},curve_number_map,{cn_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_exc_rain.le_3_pg2.text() !="" else 0},Areal_averaged_rainfall,{chuva_media if self.dlg_exc_rain.rb_1_pg1.isChecked() == True else ""}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_exc_rain.le_4_pg2.text() !="" else 0},Spatially_distributed_rainfall,{chuva_distribuida if self.dlg_exc_rain.rb_2_pg1.isChecked() == True else ""}\n')
            arquivo_txt.write(f'{1},parameters,{direct_parameters}\n')

        # Escreve aquivos de saída
        self.output1_exec_rain = direct_temp + r'\Map_of_watershed_pixels_ID.rst'
        self.output2_exec_rain = direct_temp + \
            r'\Map_of_maximum_potential_retention.rst'
        self.output3_exec_rain = direct_temp + r'\Map_of_initial_abstraction.rst'
        self.output4_exec_rain = direct_temp + r'\Map_of_total_rainfall.rst'
        self.output5_exec_rain = direct_temp + r'\Map_of_total_excess_rainfall.rst'
        self.output6_exec_rain = direct_temp + r'\Excess_hyetographs_per_pixel.txt'

        direct_out_files = direct_temp + r'\output_files_config_exc_rainf.txt'
        with open(direct_out_files, "w", encoding="utf-8") as arquivo_txt:
            arquivo_txt.write("Select output file directory\n")
            arquivo_txt.write(
                f"{1 if self.dlg_exc_rain.ch_1_pg4.isChecked() == True else 0},Map of watershed pixels ID,{self.output1_exec_rain}\n")
            arquivo_txt.write(
                f"{1 if self.dlg_exc_rain.ch_2_pg4.isChecked() == True else 0},Map of maximum potential retention (mm),{self.output2_exec_rain}\n")
            arquivo_txt.write(
                f"{1 if self.dlg_exc_rain.ch_3_pg4.isChecked() == True else 0},Map of initial abstraction (mm),{self.output3_exec_rain}\n")
            arquivo_txt.write(
                f"{1 if self.dlg_exc_rain.ch_4_pg4.isChecked() == True else 0},Map of total rainfall (mm),{self.output4_exec_rain}\n")
            arquivo_txt.write(
                f"{1 if self.dlg_exc_rain.ch_5_pg4.isChecked() == True else 0},Map of total excess rainfall (mm),{self.output5_exec_rain}\n")
            arquivo_txt.write(
                f"{1 if self.dlg_exc_rain.ch_6_pg4.isChecked() == True else 0},Excess hyetographs per pixel (mm),{self.output6_exec_rain}")

    def run_excess_rainfall(self):
        '''Está função ativa a página de log e configura a ordem de execução das funções para o cálculo da chuva excedente'''
        # Ativiva a página de log e limpa as informações passadas no text_edit
        mensagem_log1 = None
        self.dlg_exc_rain.tabWidget.setCurrentIndex(1)
        self.dlg_exc_rain.pg_log_exc_rain.setEnabled(True)
        self.dlg_exc_rain.te_logg.clear()

        # Configura a progressbar
        self.dlg_exc_rain.progressBar.setRange(0, 100)
        self.dlg_exc_rain.progressBar.setValue(0)
        self.dlg_exc_rain.progressBar.setValue(5)

        # Configura as informações do textEdit da referida página
        font = QFont()
        font.setPointSize(11)
        version_info = {
            "QGIS Version": '3.28.0-Firenze',
            "Qt Version": '5.15.3',
            "Python Version": '3.9.5',
            "GDAL Version": '3.8.0'}

        datatime_started = datetime.now().isoformat()
        mensagem_log1 = "The plugin was developed with:\n"
        mensagem_log1 += f"QGIS Version: {version_info['QGIS Version']}\n"
        mensagem_log1 += f"Qt Version: {version_info['Qt Version']}\n"
        mensagem_log1 += f"Python Version: {version_info['Python Version']}\n"
        mensagem_log1 += f"GDAL Version: {version_info['GDAL Version']}\n"
        mensagem_log1 += "--------------------------------------------------------\n"
        mensagem_log1 += f"Algorithm started at: {datatime_started}\n"
        mensagem_log1 += "--------------------------------------------------------\n"
        self.dlg_exc_rain.progressBar.setValue(10)
        # Cria condição de parada da execução: se o usuário clicar no botão cancel da página de log
        while True:
            # Método usado para permitir a iteração do usuário enquanto o programa está em execução
            QApplication.processEvents()
            self.dlg_exc_rain.btn_cancel_log.clicked.connect(lambda: self.cancel_log_page(
                self.dlg_exc_rain.te_logg, self.dlg_exc_rain.pg_par_exc_rain, self.dlg_exc_rain.pg_log_exc_rain))

            # Se não existir erros nas informações enviadas, será mostrada a página de log e o programa será executado
            self.dlg_exc_rain.pg_par_exc_rain.setEnabled(False)

            # Adiciona as mensagem de log ao text edit e configura a função run
            self.dlg_exc_rain.te_logg.append(mensagem_log1)
            for cont in range(1, 26):
                self.dlg_exc_rain.progressBar.setValue(cont)

            # Chama função que cria arquivos necessários às rotinas em vb
            self.run_process_excess_rainfall()
            self.dlg_exc_rain.progressBar.setValue(40)

            # Chama executável vb para iniciar o processamento
            exc_rain_vb = self.diretorio_atual + r'\temp\excess_rainfall.exe'
            exc_rain_exe = subprocess.run([exc_rain_vb])

            # verifica se houve algum erro no processamento das rotinas no vb ou se o usuario clicou em cancelar
            # Caso não, a execução continua no python
            if exc_rain_exe.returncode == 0:
                self.dlg_exc_rain.progressBar.setValue(60)

                # move o arquivo txt contendo o hietograma de chuva excedente para o diretório informado
                if self.dlg_exc_rain.ch_6_pg4.isChecked():

                    os.rename(self.output6_exec_rain,
                              self.dlg_exc_rain.le_6_pg4.text())

                # Converte arquivos de saída de .rst ascii para tif
                if self.dlg_exc_rain.le_6_pg4.text() != '' or self.dlg_exc_rain.le_5_pg4.text() != '':
                    # Define parâmetros da função que transforma .rst(ascii) para geotiff: Cria arquivos de saída no diretório fornecido pelo user

                    if self.dlg_exc_rain.ch_1_pg4.isChecked() == True:
                        # watershed pixels ID
                        self.leh_rst_escreve_geotiff(
                            self.output1_exec_rain, self.dlg_exc_rain.le_1_pg4.text(), 'int')

                    if self.dlg_exc_rain.ch_2_pg4.isChecked() == True:
                        # Map_of_maximum_potential_retention
                        self.leh_rst_escreve_geotiff(
                            self.output2_exec_rain, self.dlg_exc_rain.le_2_pg4.text(), 'float')

                    if self.dlg_exc_rain.ch_3_pg4.isChecked() == True:
                        # Map_of_initial_abstraction
                        self.leh_rst_escreve_geotiff(
                            self.output3_exec_rain, self.dlg_exc_rain.le_3_pg4.text(), 'float')

                    if self.dlg_exc_rain.ch_4_pg4.isChecked() == True:
                        # Map_of_total_rainfall
                        self.leh_rst_escreve_geotiff(
                            self.output4_exec_rain, self.dlg_exc_rain.le_4_pg4.text(), 'float')

                    if self.dlg_exc_rain.ch_5_pg4.isChecked() == True:
                        # Map_of_total_excess_rainfall
                        self.leh_rst_escreve_geotiff(
                            self.output5_exec_rain, self.dlg_exc_rain.le_5_pg4.text(), 'float')

                    # Atualiza progressBar
                    self.dlg_exc_rain.progressBar.setValue(80)

                    # Adição dos arquivos gerados ao QGIS
                    if self.dlg_exc_rain.ch_7_pg4.isChecked() == True:
                        # Adiciona ao QGIS o output: watershed pixels ID
                        self.adiciona_layer(self.dlg_exc_rain.le_1_pg4.text())

                    if self.dlg_exc_rain.ch_8_pg4.isChecked() == True:
                        # Adiciona ao QGIS o output: Map_of_maximum_potential_retention
                        self.adiciona_layer(self.dlg_exc_rain.le_2_pg4.text())

                    if self.dlg_exc_rain.ch_9_pg4.isChecked() == True:
                        # Adiciona ao QGIS o output: Map_of_initial_abstraction
                        self.adiciona_layer(self.dlg_exc_rain.le_3_pg4.text())

                    if self.dlg_exc_rain.ch_10_pg4.isChecked() == True:
                        # Adiciona ao QGIS o output: Map_of_total_rainfall
                        self.adiciona_layer(self.dlg_exc_rain.le_4_pg4.text())

                    if self.dlg_exc_rain.ch_11_pg4.isChecked() == True:
                        # Adiciona ao QGIS o output: Map_of_total_excess_rainfall
                        self.adiciona_layer(self.dlg_exc_rain.le_5_pg4.text())

                    # Adiciona as informação ao text edit
                    self.dlg_exc_rain.te_logg.append(
                        'Operation completed successfully!')
                    QMessageBox.information(
                        None, "Information", "Operation completed successfully!", )
                    self.dlg_exc_rain.progressBar.setValue(100)
                    self.dlg_exc_rain.pg_log_exc_rain.setEnabled(False)
                    self.dlg_exc_rain.pg_par_exc_rain.setEnabled(True)
                    self.dlg_exc_rain.te_logg.clear()
                    break
                else:
                    QMessageBox.information(
                        None, "Information", "There was an inconsistency, please verify if all files were sent!", )
                    self.dlg_exc_rain.progressBar.setValue(100)
                    self.dlg_exc_rain.te_logg.clear()
                    self.dlg_exc_rain.pg_par_exc_rain.setEnabled(True)
                    self.dlg_exc_rain.pg_log_exc_rain.setEnabled(False)
                    self.apaga_arquivos_temp()
                    break

            # Finaliza execução do programa e elimina os arquivos temporários criados
            self.apaga_arquivos_temp()
            self.dlg_exc_rain.te_logg.clear()
            self.dlg_exc_rain.pg_par_exc_rain.setEnabled(True)
            self.dlg_exc_rain.pg_log_exc_rain.setEnabled(False)
            break

    def run_process_flow_tt(self):
        """Esta função configura a escrita dos arquivos txt para integração com a linguagem visual basic"""

        # Captura diretório dos arquivo txt (pasta temp)
        direct_temp = self.diretorio_atual + r'\temp'

        # Escreve txt contendo código de direções de fluxo
        flow_directions_code = direct_temp + r'\flow_directions_code.txt'
        with open(flow_directions_code, 'w', encoding='utf-8') as arquivo_txt:
            # Escreve cabeçalho
            arquivo_txt.write('Flow Directions Code\n')
            arquivo_txt.write(f'A,{self.dlg_flow_tt.le_5_pg1.text()}\n')
            arquivo_txt.write(f'B,{self.dlg_flow_tt.le_6_pg1.text()}\n')
            arquivo_txt.write(f'C,{self.dlg_flow_tt.le_7_pg1.text()}\n')
            arquivo_txt.write(f'D,{self.dlg_flow_tt.le_8_pg1.text()}\n')
            arquivo_txt.write(f'E,{self.dlg_flow_tt.le_9_pg1.text()}\n')
            arquivo_txt.write(f'F,{self.dlg_flow_tt.le_10_pg1.text()}\n')
            arquivo_txt.write(f'G,{self.dlg_flow_tt.le_11_pg1.text()}\n')
            arquivo_txt.write(f'H,{self.dlg_flow_tt.le_12_pg1.text()}')

        # Escreve arquivo txt contento os parâmetros do modelo
        parameters_file = direct_temp + r'\parameters_flow_tt.txt'
        with open(parameters_file, 'w', encoding='utf-8') as arquivo_txt:
            arquivo_txt.write('Regional curve method is checked:')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.groupBox_3.isChecked() == True else 0}')
            arquivo_txt.write(
                f'Manning coefficient for river segments without cross-section information,{self.dlg_flow_tt.le_14_pg1.text()}\n')
            arquivo_txt.write(f'Sheet flow lenght (m),30.48\n')
            arquivo_txt.write(
                f'P24 - Rainfall depth for 24-hour duration and 2-year return period (mm),{self.dlg_flow_tt.le_11_pg2.text()}\n')
            arquivo_txt.write(f'Mean depth of lake or reservoir (m),5\n')
            arquivo_txt.write(
                f'Regional curve coefficient c,{self.dlg_flow_tt.le_16_pg1.text()}\n')
            arquivo_txt.write(
                f'Regional curve coefficient d,{self.dlg_flow_tt.le_17_pg1.text()}\n')
            arquivo_txt.write(
                f'Regional curve coefficient g,{self.dlg_flow_tt.le_18_pg1.text()}\n')
            arquivo_txt.write(
                f'Regional curve coefficient h,{self.dlg_flow_tt.le_19_pg1.text()}\n')
            arquivo_txt.write(
                f'Maximum river segment lenght for river segments without cross-section information (m),{self.dlg_flow_tt.le_15_pg1.text()}\n')
            arquivo_txt.write(
                f'Minimum slope,{self.dlg_flow_tt.le_1_pg1.text()}')

        # Escreve arquivos contendo as informações das tabelas referentes aos segmentos homogêneos da rede de drenagem e das características do uso e cobertura do solo
        self.save_table_to_file(1)
        self.save_table_to_file(2)

        # Chama funções para tranformação do raster em geotiff para rst tipo ascii
        bacia_file = direct_temp + r'\Watershed.rst'
        self.leh_geotiff_escreve_ascii(
            self.lista_rasters_dir[self.dlg_flow_tt.cb_1_pg2.currentIndex()], bacia_file, 'int')

        dem_file = direct_temp + r'\DEM.rst'
        self.leh_geotiff_escreve_ascii(
            self.lista_rasters_dir[self.dlg_flow_tt.cb_2_pg2.currentIndex()], dem_file, 'float')

        Flow_Dir_file = direct_temp + r'\Flow_dir.rst'
        self.leh_geotiff_escreve_ascii(
            self.lista_rasters_dir[self.dlg_flow_tt.cb_3_pg2.currentIndex()], Flow_Dir_file, 'int')

        drainage_file = direct_temp + r'\drainage.rst'
        self.leh_geotiff_escreve_ascii(
            self.lista_rasters_dir[self.dlg_flow_tt.cb_4_pg2.currentIndex()], drainage_file, 'int')

        river_segments_file = direct_temp + r'\river_segments.rst'
        self.leh_geotiff_escreve_ascii(
            self.lista_rasters_dir[self.dlg_flow_tt.cb_5_pg2.currentIndex()], river_segments_file, 'int')

        DA_km2_file = direct_temp + r'\DA_km2.rst'
        self.leh_geotiff_escreve_ascii(
            self.lista_rasters_dir[self.dlg_flow_tt.cb_6_pg2.currentIndex()], DA_km2_file, 'float')

        LULC_file = direct_temp + r'\LULC.rst'
        self.leh_geotiff_escreve_ascii(
            self.lista_rasters_dir[self.dlg_flow_tt.cb_7_pg2.currentIndex()], LULC_file, 'int')

        # Escreve arquivo txt com os diretórios e nome dos inputs enviados pelo user
        direct_in_files = direct_temp + r'\input_files_config_flow_tt.txt'
        with open(direct_in_files, 'w', encoding='utf-8') as arquivo_txt:
            # Escreve cabeçalho
            arquivo_txt.write("Selected input file directory\n")
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.cb_1_pg2.currentText() !="" else 0},watershed,{bacia_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.cb_2_pg2.currentText() !="" else 0},DEM,{dem_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.cb_3_pg2.currentText() !="" else 0},Flow_Dir,{Flow_Dir_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.cb_4_pg2.currentText() !="" else 0},DA_km2,{DA_km2_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.cb_5_pg2.currentText() !="" else 0},drainage,{drainage_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.cb_6_pg2.currentText() !="" else 0},river_segments,{river_segments_file}\n')

            # Arquivo obrigatório, condição apenas para manter o padrão e controle
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.cb_1_pg2.currentText() !="" else 0},segment_characteristics,{self.file_name_tb1}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.cb_7_pg2.currentText() !="" else 0},LULC,{LULC_file}\n')
            # Arquivo obrigatório, condição apenas para manter o padrão e controle
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.cb_1_pg2.currentText() !="" else 0},surface_roughness,{self.file_name_tb2}\n')
            arquivo_txt.write(f'{0},reservoirs,\n')
            # Arquivo obrigatório, condição apenas para manter o padrão e controle
            arquivo_txt.write(f'{1},parameters,{parameters_file}')

        # Organiza os caminhos dos arquivos de saída enviados pelo user: modifica a extensão de .tif para .rst
        self.output1_flow_tt = direct_temp + r'\Slope.rst'
        self.output2_flow_tt = direct_temp + r'\river_segments.rst'
        self.output3_flow_tt = direct_temp + r'\Hydraulic_radius-roughness_and_slope.txt'
        self.output4_flow_tt = direct_temp + r'\River_cross-sectional_area.rst'
        self.output5_flow_tt = direct_temp + r'\River_bankfull_width.rst'
        self.output6_flow_tt = direct_temp + r'\Flow_travel_time.rst'

        # Escreve aquivo txt contendo o diretório informado pelo user: será fornecido para a rotina em visual basic
        direct_out_files = direct_temp + r'\output_files_config_flow_tt.txt'
        with open(direct_out_files, 'w', encoding='utf-8') as arquivo_txt:
            arquivo_txt.write("Select output file directory\n")
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.ch_6_pg4.isChecked() == True else 0},Slope,{self.output1_flow_tt}\n')  # rst
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.ch_7_pg4.isChecked() == True else 0},river_segments,{self.output2_flow_tt}\n')  # rst
            # txt: gerado diretamente nas rotinas vb
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.ch_8_pg4.isChecked() == True else 0},Hydraulic_radius-roughness_and_slope,{self.output3_flow_tt}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.ch_9_pg4.isChecked() == True else 0},River_cross-sectional_area,{self.output4_flow_tt}\n')  # rst
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.ch_10_pg4.isChecked() == True else 0},River_bankfull_width,{self.output5_flow_tt}\n')  # rst
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.ch_11_pg4.isChecked() == True else 0},Flow_travel_time,{self.output6_flow_tt}')  # rst

    def run_flow_tt(self):
        '''Está função ativa a página de log e configura a ordem de execução das funções para o cálculo do tempo de viagem'''
        # Ativiva a página de log e limpa as informações passadas no text_edit
        mensagem_log1 = None
        self.dlg_flow_tt.tabWidget.setCurrentIndex(1)
        self.dlg_flow_tt.pg_log_ftt.setEnabled(True)
        self.dlg_flow_tt.te_logg.clear()

        # Configura a progressbar
        self.dlg_flow_tt.progressBar.setRange(0, 100)
        self.dlg_flow_tt.progressBar.setValue(0)
        self.dlg_flow_tt.progressBar.setValue(5)

        # Configura as informações do textEdit da referida página
        font = QFont()
        font.setPointSize(11)
        version_info = {
            "QGIS Version": '3.28.0-Firenze',
            "Qt Version": '5.15.3',
            "Python Version": '3.9.5',
            "GDAL Version": '3.8.0'}

        datatime_started = datetime.now().isoformat()
        mensagem_log1 = "The plugin was developed with:\n"
        mensagem_log1 += f"QGIS Version: {version_info['QGIS Version']}\n"
        mensagem_log1 += f"Qt Version: {version_info['Qt Version']}\n"
        mensagem_log1 += f"Python Version: {version_info['Python Version']}\n"
        mensagem_log1 += f"GDAL Version: {version_info['GDAL Version']}\n"
        mensagem_log1 += "--------------------------------------------------------\n"
        mensagem_log1 += f"Algorithm started at: {datatime_started}\n"
        mensagem_log1 += "--------------------------------------------------------\n"
        self.dlg_flow_tt.progressBar.setValue(10)
        # Cria condição de parada da execução: se o usuário clicar no botão cancel da página de log
        while True:
            # Método usado para permitir a iteração do usuário enquanto o programa está em execução
            QApplication.processEvents()
            self.dlg_flow_tt.btn_cancel_log.clicked.connect(lambda: self.cancel_log_page(
                self.dlg_flow_tt.te_logg, self.dlg_flow_tt.pg_par_ftt, self.dlg_flow_tt.pg_log_ftt))

            # Verifica a existência de incoerências nas informações (direções de fluxo) fornecidas pelo usuário
            list_line_edit_value_pg1 = [self.dlg_flow_tt.le_5_pg1.text(),
                                        self.dlg_flow_tt.le_6_pg1.text(),
                                        self.dlg_flow_tt.le_7_pg1.text(),
                                        self.dlg_flow_tt.le_8_pg1.text(),
                                        self.dlg_flow_tt.le_9_pg1.text(),
                                        self.dlg_flow_tt.le_10_pg1.text(),
                                        self.dlg_flow_tt.le_11_pg1.text(),
                                        self.dlg_flow_tt.le_12_pg1.text()
                                        ]
            duplicate = []
            # Verifica se há duplicatas no código
            for i in range(len(list_line_edit_value_pg1)):
                for j in range(i+1, len(list_line_edit_value_pg1)):
                    if list_line_edit_value_pg1[i] == list_line_edit_value_pg1[j]:
                        # Para os elementos iguais, armazena eles em uma lista
                        duplicate.append(list_line_edit_value_pg1[i])

            if any(item == '' for item in duplicate):
                self.dlg_flow_tt.pages_flow_tt.setCurrentIndex(0)
                # Vefica se os códigos das diferções de drenagem foram corretamente enviados
                QMessageBox.warning(self.dlg_flow_tt, 'Warning',
                                    "Direction codes might not None.")
                return

            elif duplicate and all(item != '' for item in duplicate):
                self.dlg_flow_tt.pages_flow_tt.setCurrentIndex(0)
                # O usuário enviou 2 valores semelhantes, será mostrado uma mensagem de erro
                QMessageBox.warning(
                    self.dlg_flow_tt, 'Warning', f"The value(s) '{duplicate}' is(are) (a) duplicate(s)! Direction codes do not accept duplicates.")
                return

            else:
                # Se não existir erros nas informações enviadas, será mostrada a página de log e o programa será executado
                self.dlg_flow_tt.pg_par_ftt.setEnabled(False)

                # Adiciona as mensagem de log ao text edit e configura a função run
                self.dlg_flow_tt.te_logg.append(mensagem_log1)
                for cont in range(1, 26):
                    self.dlg_flow_tt.progressBar.setValue(cont)

                self.run_process_flow_tt()
                self.dlg_flow_tt.progressBar.setValue(40)

                # Chama executável vb para iniciar o processamento
                travel_time_vb = self.diretorio_atual + r'\temp\Travel_Time.exe'
                flow_tt_exe = subprocess.run([travel_time_vb])

                # verifica se houve algum erro no processamento das rotinas no vb ou se o usuario clicou em cancelar
                # Caso não, a execução continua no python
                if flow_tt_exe.returncode == 0:
                    self.dlg_flow_tt.progressBar.setValue(60)

                    # Move e renomeia arquivo txt com as características dos trechos de rios semelhantes
                    if self.dlg_flow_tt.ch_8_pg4.isChecked() == True and os.path.isfile(self.output3_flow_tt) == True:
                        shutil.copy(self.output3_flow_tt,
                                    self.dlg_flow_tt.le_8_pg4.text())

                    if os.path.isfile(self.output6_flow_tt) == True:
                        # Define parâmetros da função que transforma .rst(ascii) para geotiff: Cria arquivos de saída no diretório fornecido pelo user
                        if self.dlg_flow_tt.ch_6_pg4.isChecked() == True:
                            # slope
                            self.leh_rst_escreve_geotiff(
                                self.output1_flow_tt, self.dlg_flow_tt.le_6_pg4.text(), 'float')

                        if self.dlg_flow_tt.ch_7_pg4.isChecked() == True:
                            # river_segmentsself.
                            self.leh_rst_escreve_geotiff(
                                self.output2_flow_tt, self.dlg_flow_tt.le_7_pg4.text(), 'int')

                        if self.dlg_flow_tt.ch_9_pg4.isChecked() == True:
                            # River_cross-sectional_area
                            self.leh_rst_escreve_geotiff(
                                self.output4_flow_tt, self.dlg_flow_tt.le_9_pg4.text(), 'float')

                        if self.dlg_flow_tt.ch_10_pg4.isChecked() == True:
                            # River_bankfull_width
                            self.leh_rst_escreve_geotiff(
                                self.output5_flow_tt, self.dlg_flow_tt.le_10_pg4.text(), 'float')

                        if self.dlg_flow_tt.ch_11_pg4.isChecked() == True:
                            # Flow_travel_time
                            self.leh_rst_escreve_geotiff(
                                self.output6_flow_tt, self.dlg_flow_tt.le_11_pg4.text(), 'float')

                        # Atualiza progressBar
                        self.dlg_flow_tt.progressBar.setValue(80)

                        # Adição dos arquivos gerados ao QGIS
                        if self.dlg_flow_tt.ch_17_pg4.isChecked() == True:
                            # Adiciona ao QGIS o output: slope
                            self.adiciona_layer(
                                self.dlg_flow_tt.le_6_pg4.text())

                        if self.dlg_flow_tt.ch_18_pg4.isChecked() == True:
                            # Adiciona ao QGIS o output: river_segments
                            self.adiciona_layer(
                                self.dlg_flow_tt.le_7_pg4.text())

                        if self.dlg_flow_tt.ch_20_pg4.isChecked() == True:
                            # Adiciona ao QGIS o output: River_cross-sectional_area
                            self.adiciona_layer(
                                self.dlg_flow_tt.le_9_pg4.text())

                        if self.dlg_flow_tt.ch_21_pg4.isChecked() == True:
                            # Adiciona ao QGIS o output: River_bankfull_width
                            self.adiciona_layer(
                                self.dlg_flow_tt.le_10_pg4.text())

                        if self.dlg_flow_tt.ch_22_pg4.isChecked() == True:
                            # Adiciona ao QGIS o output: flow travel time
                            self.adiciona_layer(
                                self.dlg_flow_tt.le_11_pg4.text())

                        # Adiciona as informação ao text edit
                        self.dlg_flow_tt.te_logg.append(
                            'Operation completed successfully!')
                        QMessageBox.information(
                            None, "Information", "Operation completed successfully!", )
                        self.dlg_flow_tt.progressBar.setValue(100)
                        self.dlg_flow_tt.pg_log_ftt.setEnabled(False)
                        self.dlg_flow_tt.pg_par_ftt.setEnabled(True)
                        self.dlg_flow_tt.te_logg.clear()
                        break
                else:
                    QMessageBox.information(
                        None, "Information", "There was an inconsistency, please verify if all files were sent!", )
                    self.dlg_flow_tt.progressBar.setValue(100)
                    self.dlg_flow_tt.te_logg.clear()
                    self.dlg_flow_tt.pg_par_ftt.setEnabled(True)
                    self.dlg_flow_tt.pg_log_ftt.setEnabled(False)
                    self.apaga_arquivos_temp()
                    break

    def run_process_flow_rout(self):
        """Esta função organiza os arquivos de entrada para as rotinas em vb apartir do plugin qgis"""
        # Captura diretório dos arquivo txt (pasta temp)
        direct_temp = self.diretorio_atual + r'\temp'

        # Escreve arquivos de parâmetros
        parameters_flow_rout = direct_temp + r'\parameters_exc_rainf.txt'
        with open(parameters_flow_rout, 'w', encoding='utf-8') as arquivo_txt:
            arquivo_txt.write(
                f"Rainfall time step (min),{self.dlg_flow_rout.le_2_pg1.text()}\n")
            arquivo_txt.write(
                f"Parameter β,{self.dlg_flow_rout.le_5_pg1.text()}\n")
            arquivo_txt.write(
                f"L/s,{1 if self.dlg_flow_rout.rb_3_pg4.isChecked() == True else 0}\n")
            arquivo_txt.write(
                f"m3/s,{1 if self.dlg_flow_rout.rb_4_pg4.isChecked() == True else 0}")

        # Chama funções para tranformação do raster em geotiff para rst tipo ascii
        bacia_file = direct_temp + r'\Watershed.rst'
        self.leh_geotiff_escreve_ascii(
            self.lista_rasters_dir[self.dlg_flow_rout.cb_1_pg2.currentIndex()], bacia_file, 'int')

        # Versao TUH
        # pixels_id_file = direct_temp + r'\map_pixels_id.rst'
        # self.leh_geotiff_escreve_ascii(
        #     self.dlg_flow_rout.le_2_pg2.text(), pixels_id_file, 'int')

        flow_tt_file = direct_temp + r'\flow_tt.rst'
        self.leh_geotiff_escreve_ascii(
            self.lista_rasters_dir[self.dlg_flow_rout.cb_3_pg2.currentIndex()], flow_tt_file, 'float')

        hietograma_file = direct_temp + r'\excess_hyetographs.txt'
        shutil.copy(self.dlg_flow_rout.le_4_pg2.text(), hietograma_file)

        total_exc_rain_file = direct_temp + r'\total_excess_rainfall.rst'
        self.leh_geotiff_escreve_ascii(
            self.lista_rasters_dir[self.dlg_flow_rout.cb_5_pg2.currentIndex()], total_exc_rain_file, 'float')

        if self.dlg_flow_rout.groupBox_2.isChecked() == True:
            watershed_into_classes = direct_temp + r'\watershed_into_classes.rst'
            self.leh_geotiff_escreve_ascii(
                self.lista_rasters_dir[self.dlg_flow_rout.cb_4_pg2.currentIndex()], watershed_into_classes, 'int', mapa_classes='y')
        else:
            watershed_into_classes = ""

        # Escreve txt contendo código de direções de fluxo
        flow_directions_code = direct_temp + r'\input_files_config_flow_rout.txt'
        with open(flow_directions_code, 'w', encoding='utf-8') as arquivo_txt:
            arquivo_txt.write("Selected input files directory\n")
            arquivo_txt.write(
                f'{1 if self.dlg_flow_rout.cb_1_pg2.currentText() !="" else 0},watershed,{bacia_file}\n')
            # Versao TUH
            # arquivo_txt.write(
            #     f'{1 if self.dlg_flow_rout.le_2_pg2.text() !="" else 0},map_pixels_id,{pixels_id_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_rout.cb_3_pg2.currentText() !="" else 0},flow_travel_time,{flow_tt_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_rout.le_4_pg2.text() !="" else 0},excess_hyetographs,{hietograma_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_rout.cb_5_pg2.currentText() !="" else 0},total_excess_rainfall,{total_exc_rain_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_rout.cb_4_pg2.currentText() !="" else 0},watershed_into_classes,{watershed_into_classes}\n')
            arquivo_txt.write(f'{1},parameters,{parameters_flow_rout}')

        self.output1_flow_rout = direct_temp + r'\map_of_resulting_peak_discharge.rst'
        self.output2_flow_rout = direct_temp + r'\map_of_resulting_runoff_volume.rst'
        self.output3_flow_rout = direct_temp + r'\resulting_watershed_hydrograph.txt'

        # Escreve aquivo txt contendo o diretório informado pelo user: será fornecido para a rotina em visual basic
        direct_out_files = direct_temp + r'\output_files_config_flow_rout.txt'
        with open(direct_out_files, 'w', encoding='utf-8') as arquivo_txt:
            arquivo_txt.write("Selected output files directory\n")
            arquivo_txt.write(
                f'{1 if self.dlg_flow_rout.ch_4_pg4.isChecked() == True else 0},map_of_resulting_peak_discharge,{self.output1_flow_rout}\n')  # rst
            arquivo_txt.write(
                f'{1 if self.dlg_flow_rout.ch_5_pg4.isChecked() == True else 0},map_of_resulting_runoff_volume,{self.output2_flow_rout}\n')  # rst
            arquivo_txt.write(
                f'{1 if self.dlg_flow_rout.ch_6_pg4.isChecked() == True else 0},resulting_watershed_hydrograph,{self.output3_flow_rout}')  # txt

    def plot_hidrogramas_e_metricas(self):
        """Esta função gera o hidrograma calculado vs observado e adiciona as métricas de comparação"""
        # leh hidrograma observado
        cont = 0
        if self.dlg_flow_rout.ch_12_pg4.isChecked() == True and self.dlg_flow_rout.le_6_pg4.text() != '' and self.dlg_flow_rout.le_7_pg4.text() == '':
            hidrograma_calc = self.dlg_flow_rout.le_6_pg4.text()
            with open(hidrograma_calc, 'r', encoding='ISO-8859-1') as f:
                header = f.readline().strip().split(',')

            # Armazena a legenda do grafico
            header[1] = 'Calculated Runoff'

            # Carrega as vazoes (pula a primeira linha, usa vírgula como separador)
            data = np.loadtxt(hidrograma_calc, skiprows=1, delimiter=',')

            # A primeira coluna e o tempo
            tempos = data[:, 0]

            # Determinacao do delta
            if len(tempos) > 1:
                delta_t = tempos[1] - tempos[0]
            else:
                delta_t = 0

            # Cria grafico e delimita tamanho de exibicao
            plt.figure(figsize=(8, 6))
            plt.gcf().canvas.manager.window.setWindowTitle('Resulting Watershed Hydrograph')
            plt.title('HYDROGRAPH')

            # Plot dos hidrogramas calculados
            for i in range(1, data.shape[1]):
                plt.plot(tempos, data[:, i], label=header[i].strip())
            plt.xlabel('time (min)')
            plt.ylabel('Q (m³/s)')
            plt.legend()
            plt.grid()
            plt.show()
        # Plota, se marcado, o hidrograma calculado e o observado e calcula as metricas
        elif self.dlg_flow_rout.ch_12_pg4.isChecked() == True and self.dlg_flow_rout.le_6_pg4.text() != '' and self.dlg_flow_rout.le_7_pg4.text() == '' and self.dlg_flow_rout.cb_4_pg2.currentText() == '':
            hidrograma_obs = self.dlg_flow_rout.le_7_pg4.text()
            hidrograma_calc = self.dlg_flow_rout.le_6_pg4.text()

            # Leitura do hidrograma observado
            with open(hidrograma_obs, 'r', encoding='ISO-8859-1') as f:
                header_obs = f.readline().strip().split(',')
                nomes_obs = header_obs[1:]  # descarta o tempo
                data_obs = np.loadtxt(f, delimiter=',')
            tempos_obs = data_obs[:, 0]
            vazoes_obs = data_obs[:, 1:]  # pode ter várias colunas

            # Leitura do hidrograma calculado
            with open(hidrograma_calc, 'r', encoding='ISO-8859-1') as f:
                header_calc = f.readline().strip().split(',')
                nomes_calc = header_calc[1:]
                data_calc = np.loadtxt(f, delimiter=',')
            tempos_calc = data_calc[:, 0]
            vazoes_calc = data_calc[:, 1:]

            #  Cálculo de delta_t
            delta_t = tempos_obs[1] - tempos_obs[0]

            # Plotagem
            plt.figure(figsize=(8, 6))
            plt.gcf().canvas.manager.window.setWindowTitle('Resulting Watershed Hydrograph')
            plt.title('HYDROGRAPH')

            # Observado (primeira coluna de vazões observadas) em preto
            plt.plot(tempos_obs, vazoes_obs[:, 0], color='black',
                     linestyle='-', label='Observed Runoff')

            # Calculado total (primeira coluna de vazões calculadas) em vermelho
            plt.plot(tempos_calc, vazoes_calc[:, 0], color='red',
                     linestyle='-', label='Calculated Runoff')

            plt.xlabel('time (min)')
            plt.ylabel('Q(m³/s)')

            # legenda no canto superior direito, vertical e fonte reduzida
            plt.legend(loc='upper right', fontsize='small')

            plt.grid()

            # Métricas de comparação
            q_obs = vazoes_obs[:, 0]
            q_calc = vazoes_calc[:, 0]
            er_vazao_pico = (np.max(q_calc) - np.max(q_obs)) / \
                np.max(q_obs) * 100
            er_tempo_pico = ((tempos_calc[np.argmax(
                q_calc)] - tempos_obs[np.argmax(q_obs)]) / tempos_obs[np.argmax(q_obs)]) * 100
            nse = 1 - (np.sum((q_calc - q_obs)**2) /
                       np.sum((q_obs - np.mean(q_obs))**2))
            rmse = np.sqrt(np.mean((q_calc - q_obs)**2))
            vol_obs = np.sum(q_obs) * delta_t
            vol_calc = np.sum(q_calc) * delta_t
            er_vol = (vol_calc - vol_obs) / vol_obs * 100

            # mantém as posições originais das métricas
            plt.figtext(0.1, 0.25, f'RMSE: {rmse:.2f}m³/s', fontsize=10)
            plt.figtext(0.1, 0.20, f'NS coefficient: {nse:.2f}', fontsize=10)
            plt.figtext(
                0.1, 0.15, f'relative peak error: {er_vazao_pico:.2f}%', fontsize=10)
            plt.figtext(
                0.1, 0.10, f'relative time to peak error: {er_tempo_pico:.2f}%', fontsize=10)
            plt.figtext(
                0.1, 0.05, f'relative volume error: {er_vol:.2f}%', fontsize=10)

            plt.subplots_adjust(bottom=0.40)
            plt.show()

        # Plota, se marcado, o hidrograma observado, calculado e tambem as vazoes por classe e calcula as metricas da vazao obs e calculada (sera extinto)
        elif self.dlg_flow_rout.ch_12_pg4.isChecked() == True and self.dlg_flow_rout.le_6_pg4.text() != '' and self.dlg_flow_rout.le_7_pg4.text() != '' and self.dlg_flow_rout.cb_4_pg2.currentText() != '':
            hidrograma_obs = self.dlg_flow_rout.le_7_pg4.text()
            hidrograma_calc = self.dlg_flow_rout.le_6_pg4.text()

            # Leitura do hidrograma observado
            with open(hidrograma_obs, 'r', encoding='ISO-8859-1') as f:
                header_obs = f.readline().strip().split(',')
                nomes_obs = header_obs[1:]  # descarta o tempo
                data_obs = np.loadtxt(f, delimiter=',')
            tempos_obs = data_obs[:, 0]
            vazoes_obs = data_obs[:, 1:]  # pode ter várias colunas

            # Leitura do hidrograma calculado
            with open(hidrograma_calc, 'r', encoding='ISO-8859-1') as f:
                header_calc = f.readline().strip().split(',')
                nomes_calc = header_calc[1:]
                data_calc = np.loadtxt(f, delimiter=',')
            tempos_calc = data_calc[:, 0]
            vazoes_calc = data_calc[:, 1:]

            #  Cálculo de delta_t
            delta_t = tempos_obs[1] - tempos_obs[0]

            # Plotagem
            plt.figure(figsize=(8, 6))
            plt.gcf().canvas.manager.window.setWindowTitle('Resulting Watershed Hydrograph')
            plt.title('HYDROGRAPH')

            # Observado (primeira coluna de vazões observadas) em preto
            plt.plot(tempos_obs, vazoes_obs[:, 0], color='black',
                     linestyle='-', label='Observed Runoff')

            # Calculado total (primeira coluna de vazões calculadas) em vermelho
            plt.plot(tempos_calc, vazoes_calc[:, 0], color='red',
                     linestyle='-', label='Calculated Runoff')

            # As demais classes calculadas, cada uma com estilo contínuo e cor padrão do matplotlib
            for j in range(1, vazoes_calc.shape[1]):
                plt.plot(tempos_calc, vazoes_calc[:, j],
                         linestyle='-', label=nomes_calc[j])

            plt.xlabel('time (min)')
            plt.ylabel('Q(m³/s)')

            # legenda no canto superior direito, vertical e fonte reduzida
            plt.legend(loc='upper right', fontsize='small')

            plt.grid()

            # Métricas de comparação
            q_obs = vazoes_obs[:, 0]
            q_calc = vazoes_calc[:, 0]
            er_vazao_pico = (np.max(q_calc) - np.max(q_obs)) / \
                np.max(q_obs) * 100
            er_tempo_pico = ((tempos_calc[np.argmax(
                q_calc)] - tempos_obs[np.argmax(q_obs)]) / tempos_obs[np.argmax(q_obs)]) * 100
            nse = 1 - (np.sum((q_calc - q_obs)**2) /
                       np.sum((q_obs - np.mean(q_obs))**2))
            rmse = np.sqrt(np.mean((q_calc - q_obs)**2))
            vol_obs = np.sum(q_obs) * delta_t
            vol_calc = np.sum(q_calc) * delta_t
            er_vol = (vol_calc - vol_obs) / vol_obs * 100

            # mantém as posições originais das métricas
            plt.figtext(0.1, 0.25, f'RMSE: {rmse:.2f}m³/s', fontsize=10)
            plt.figtext(0.1, 0.20, f'NS coefficient: {nse:.2f}', fontsize=10)
            plt.figtext(
                0.1, 0.15, f'relative peak error: {er_vazao_pico:.2f}%', fontsize=10)
            plt.figtext(
                0.1, 0.10, f'relative time to peak error: {er_tempo_pico:.2f}%', fontsize=10)
            plt.figtext(
                0.1, 0.05, f'relative volume error: {er_vol:.2f}%', fontsize=10)

            plt.subplots_adjust(bottom=0.40)
            plt.show()

    def run_flow_routing(self):
        '''Está função ativa a página de log e configura a ordem de execução das funções para o cálculo do tempo de viagem'''
        # Ativiva a página de log e limpa as informações passadas no text_edit
        mensagem_log1 = None
        self.dlg_flow_rout.tabWidget.setCurrentIndex(1)
        self.dlg_flow_rout.pg_log_f_rout.setEnabled(True)
        self.dlg_flow_rout.te_logg.clear()

        # Configura a progressbar
        self.dlg_flow_rout.progressBar.setRange(0, 100)
        self.dlg_flow_rout.progressBar.setValue(0)
        self.dlg_flow_rout.progressBar.setValue(5)

        # Configura as informações do textEdit da referida página
        font = QFont()
        font.setPointSize(11)
        version_info = {
            "QGIS Version": '3.28.0-Firenze',
            "Qt Version": '5.15.3',
            "Python Version": '3.9.5',
            "GDAL Version": '3.8.0'}

        datatime_started = datetime.now().isoformat()
        mensagem_log1 = "The plugin was developed with:\n"
        mensagem_log1 += f"QGIS Version: {version_info['QGIS Version']}\n"
        mensagem_log1 += f"Qt Version: {version_info['Qt Version']}\n"
        mensagem_log1 += f"Python Version: {version_info['Python Version']}\n"
        mensagem_log1 += f"GDAL Version: {version_info['GDAL Version']}\n"
        mensagem_log1 += "--------------------------------------------------------\n"
        mensagem_log1 += f"Algorithm started at: {datatime_started}\n"
        mensagem_log1 += "--------------------------------------------------------\n"
        self.dlg_flow_rout.progressBar.setValue(10)
        # Cria condição de parada da execução: se o usuário clicar no botão cancel da página de log
        while True:
            # Método usado para permitir a iteração do usuário enquanto o programa está em execução
            QApplication.processEvents()
            self.dlg_flow_rout.btn_cancel_log.clicked.connect(lambda: self.cancel_log_page(
                self.dlg_flow_rout.te_logg, self.dlg_flow_rout.pg_par_f_rout, self.dlg_flow_rout.pg_log_f_rout))
            self.dlg_flow_rout.pg_par_f_rout.setEnabled(False)

            # Adiciona as mensagem de log ao text edit e configura a função run
            self.dlg_flow_rout.te_logg.append(mensagem_log1)
            for cont in range(1, 26):
                self.dlg_flow_rout.progressBar.setValue(cont)

            self.run_process_flow_rout()
            self.dlg_flow_rout.progressBar.setValue(40)

            # Chama executável vb para iniciar o processamento
            flow_rout_vb = self.diretorio_atual + r'\temp\HidropixelDLR.exe'
            flow_rout_exe = subprocess.run([flow_rout_vb])

            # verifica se houve algum erro no processamento das rotinas no vb ou se o usuario clicou em cancelar
            # Caso não, a execução continua no python
            if flow_rout_exe.returncode == 0:
                self.dlg_flow_rout.progressBar.setValue(60)

                # Copia e renomeia arquivo txt do hidrograma final
                if self.dlg_flow_rout.ch_6_pg4.isChecked() == True and self.dlg_flow_rout.le_6_pg4.text() != '':
                    shutil.copy(self.output3_flow_rout,
                                self.dlg_flow_rout.le_6_pg4.text())

                if self.dlg_flow_rout.le_6_pg4.text() != '':
                    # Define parâmetros da função que transforma .rst(ascii) para geotiff: Cria arquivos de saída no diretório fornecido pelo user
                    if self.dlg_flow_rout.ch_4_pg4.isChecked() == True:
                        # peak discharge
                        self.leh_rst_escreve_geotiff(
                            self.output1_flow_rout, self.dlg_flow_rout.le_4_pg4.text(), 'float')

                    if self.dlg_flow_rout.ch_5_pg4.isChecked() == True:
                        # runboff volume
                        self.leh_rst_escreve_geotiff(
                            self.output2_flow_rout, self.dlg_flow_rout.le_5_pg4.text(), 'float')

                        # Adição dos arquivos gerados ao QGIS
                    if self.dlg_flow_rout.ch_10_pg4.isChecked() == True:
                        # Adiciona ao QGIS o output: slope
                        self.adiciona_layer(self.dlg_flow_rout.le_4_pg4.text())

                    if self.dlg_flow_rout.ch_11_pg4.isChecked() == True:
                        # Adiciona ao QGIS o output: slope
                        self.adiciona_layer(self.dlg_flow_rout.le_5_pg4.text())

                    # Chama função que gera hidrograma final
                    if self.dlg_flow_rout.ch_12_pg4.isChecked() == True:
                        self.plot_hidrogramas_e_metricas()

                    # Adiciona as informação ao text edit
                    self.dlg_flow_rout.te_logg.append(
                        'Operation completed successfully!')
                    QMessageBox.information(
                        None, "Information", "Operation completed successfully!", )
                    self.dlg_flow_rout.progressBar.setValue(100)
                    self.dlg_flow_rout.pg_log_f_rout.setEnabled(False)
                    self.dlg_flow_rout.pg_par_f_rout.setEnabled(True)
                    self.dlg_flow_rout.te_logg.clear()
                    break
            else:
                QMessageBox.information(
                    None, "Information", "There was an inconsistency, please verify if all files were sent!", )
                self.dlg_flow_rout.progressBar.setValue(100)
                self.dlg_flow_rout.te_logg.clear()
                self.dlg_flow_rout.pg_par_f_rout.setEnabled(True)
                self.dlg_flow_rout.pg_log_f_rout.setEnabled(False)
                self.apaga_arquivos_temp()
                break

    def atualiza_raster_list(self):
        """
        Reconstrói do zero a lista única de (nome, path) na ordem do painel de camadas.
        Retorna apenas a lista de nomes (para popular os combos) e armazena em 
        self.lista_rasters_dir os paths na mesma ordem.
        """
        # Limpa listas antigas
        self.lista_rasters_dir = [None]
        lista_rasters = [None]

        # Percorre a árvore de camadas na ordem visual do QGIS
        layer_tree_layers = QgsProject.instance().layerTreeRoot().findLayers()
        vistos = set()
        for node in layer_tree_layers:
            layer = node.layer()
            if layer.type() == QgsMapLayer.RasterLayer:
                nome = layer.name()
                path = layer.source()
                # garante pares únicos
                if (nome, path) not in vistos:
                    vistos.add((nome, path))
                    self.lista_rasters_dir.append(path)
                    lista_rasters.append(nome)

        return lista_rasters

    def carrega_rasters(self):
        """Esta função realiza o carregamento dos raster contidos no projeto do qgis e adiciona aos respectivos comboboxes
        funcao: indica a rotina do hidropixel
        funcao = 1: Flow Travel Time
        funcao = 2: Excess Rainfall
        funcao = 3: Flow Routing"""

        # adiciona layers raster ao combox
        nomes = self.atualiza_raster_list()

        # lista com combo boxes por rotina
        combos = [
            self.dlg_flow_tt.cb_1_pg2,
            self.dlg_flow_tt.cb_2_pg2,
            self.dlg_flow_tt.cb_3_pg2,
            self.dlg_flow_tt.cb_4_pg2,
            self.dlg_flow_tt.cb_5_pg2,
            self.dlg_flow_tt.cb_6_pg2,
            self.dlg_flow_tt.cb_7_pg2,
            self.dlg_exc_rain.cb_1_pg_ri,
            self.dlg_exc_rain.cb_1_pg2,
            self.dlg_exc_rain.cb_2_pg2,
            self.dlg_flow_rout.cb_1_pg2,
            self.dlg_flow_rout.cb_2_pg2,
            self.dlg_flow_rout.cb_3_pg2,
            self.dlg_flow_rout.cb_4_pg2,
            self.dlg_flow_rout.cb_5_pg2
        ]

        for cb in combos:
            atual = cb.currentText()
            cb.clear()
            cb.addItems(nomes)
            # se o valor antigo ainda existir, refaz a seleção
            if atual in nomes:
                cb.setCurrentText(atual)

    def SsButoes(self, active_button, instancia, page=0):
        """Esta função configura o estilo dos botões das diferentes páginas do plugin. Aquele que estiver em destaque representará a página autal
        page = 1 representa o form Excess Rainfall
        page = 0 representa os outros forms"""

        # Defina os estilos para o botão ativo e o padrão
        default_style = ""
        self.highlighted_style = "background-color: rgb(173, 216, 230)"

        # Significa que o form atual é o excess rainfall
        if page == 1:
            # Lista dos botões
            buttons = [
                instancia.btn_config,
                instancia.btn_rain_int,
                instancia.btn_input_data,
                instancia.btn_data_va_tool,
                instancia.btn_run
            ]
        else:
            buttons = [
                instancia.btn_config,
                instancia.btn_input_data,
                instancia.btn_data_va_tool,
                instancia.btn_run
            ]
        # Aplica o estilo ativo ao botão clicado e o estilo padrão aos outros
        for btn in buttons:
            if btn == active_button:
                btn.setStyleSheet(self.highlighted_style)
            else:
                btn.setStyleSheet(default_style)

    def atualizaVazaoObs(self):
        if self.dlg_flow_rout.ch_12_pg4.isChecked():
            self.dlg_flow_rout.label_64.setEnabled(True)
            self.dlg_flow_rout.le_7_pg4.setEnabled(True)
            self.dlg_flow_rout.tbtn_pg4_7.setEnabled(True)
            self.dlg_flow_rout.label_55.setEnabled(True)
        else:
            self.dlg_flow_rout.label_64.setEnabled(False)
            self.dlg_flow_rout.le_7_pg4.setEnabled(False)
            self.dlg_flow_rout.tbtn_pg4_7.setEnabled(False)
            self.dlg_flow_rout.label_55.setEnabled(False)

    def CondicaoRunFlowTT(self):
        """Esta função verifica se para cada etapa do hidropixel ao menos o output recomendado foi selecionado, caso sim, o botão RUN será liberado; do contrário, não."""
        if self.dlg_flow_tt.le_11_pg4.text() != '':
            self.run_flow_tt()

        else:
            result = r'Provide a valid directory for the outputs!'
            QMessageBox.warning(None, "Invalid directory provided", result)

    def CondicaoRunRainfall_inter(self, map_out):
        """Esta função verifica se para cada etapa do hidropixel ao menos o output recomendado foi selecionado, caso sim, o botão RUN será liberado; do contrário, não."""
        if self.dlg_flow_tt.cb_1_pg_ri.currentText() != '' and self.dlg_flow_tt.le_2_pg_ri.text() != '' and self.dlg_flow_tt.le_3_pg_ri.text() != '':
            self.run_rainfall_interpolation(map_out)

        else:
            result = 'Provide a valid directory for the outputs!'
            QMessageBox.warning(None, "Invalid directory provided", result)

    def condicaoRunExcessRainfall(self):
        """Esta função verifica se para cada etapa do hidropixel ao menos o output recomendado foi selecionado, caso sim, o botão RUN será liberado; do contrário, não."""
        if self.dlg_exc_rain.le_5_pg4.text() != '' and self.dlg_exc_rain.le_6_pg4.text() != '':
            self.run_excess_rainfall()

        else:
            result = 'Provide a valid directory for the outputs!'
            QMessageBox.warning(None, "Invalid directory provided", result)

    def condicaoRunFlowRouting(self):
        """Esta função verifica se para cada etapa do hidropixel ao menos o output recomendado foi selecionado, caso sim, o botão RUN será liberado; do contrário, não."""
        if self.dlg_flow_rout.le_6_pg4.text() != '':
            self.run_flow_routing()

        else:
            result = 'Provide a valid directory for the outputs!'
            QMessageBox.warning(None, "Invalid directory provided", result)

    def get_project_dir(self, interface):
        """Solicita diretorio para armazenar projeto do Hidropixel"""
        while True:
            file_name, _ = QFileDialog.getSaveFileName(
                None, "Save the project!", interface.le_1_pg1.text(), "Hidropixel project (*.hpx)")

            if not file_name:
                result = "Wait! You did not select any directory."
                reply = QMessageBox.warning(
                    None, "No file selected", result, QMessageBox.Ok)
                if reply == QMessageBox.Ok:
                    break

            else:
                interface.le_2_pg1.setText(file_name)
                break

    def parameters_mask(self):
        """Aplica mascara aos com os parametros para aceitar apenas valores numericos"""
        # define validatos
        int_validator = QIntValidator()
        float_validadator = QDoubleValidator()

        # Flow Travel Time
        self.dlg_flow_tt.le_1_pg1.setValidator(float_validadator)
        self.dlg_flow_tt.le_3_pg1.setValidator(float_validadator)
        self.dlg_flow_tt.le_4_pg1.setValidator(float_validadator)
        self.dlg_flow_tt.le_5_pg1.setValidator(int_validator)
        self.dlg_flow_tt.le_6_pg1.setValidator(int_validator)
        self.dlg_flow_tt.le_7_pg1.setValidator(int_validator)
        self.dlg_flow_tt.le_8_pg1.setValidator(int_validator)
        self.dlg_flow_tt.le_9_pg1.setValidator(int_validator)
        self.dlg_flow_tt.le_10_pg1.setValidator(int_validator)
        self.dlg_flow_tt.le_11_pg1.setValidator(int_validator)
        self.dlg_flow_tt.le_12_pg1.setValidator(int_validator)
        self.dlg_flow_tt.le_14_pg1.setValidator(float_validadator)
        self.dlg_flow_tt.le_15_pg1.setValidator(float_validadator)
        self.dlg_flow_tt.le_16_pg1.setValidator(float_validadator)
        self.dlg_flow_tt.le_17_pg1.setValidator(float_validadator)
        self.dlg_flow_tt.le_18_pg1.setValidator(float_validadator)
        self.dlg_flow_tt.le_19_pg1.setValidator(float_validadator)

        # Excess Rainfall
        self.dlg_exc_rain.le_1_pg1.setValidator(float_validadator)

        # Flow Routing
        self.dlg_flow_rout.le_5_pg1.setValidator(float_validadator)
        self.dlg_flow_rout.le_2_pg1.setValidator(float_validadator)

    def run_save_project(self, interface, function):
        """Organiza logica de execucao da rotina que salva projeto .hpx"""
        # So salva se nome e diretorio do projeto for fornecido
        if interface.le_1_pg1.text() != '' and interface.le_2_pg1.text() != '':
            self.save_to_project(function, interface.le_2_pg1.text())
            QMessageBox.information(
                None, "Project saved", "Operation completed successfully", QMessageBox.Ok)
        else:
            result = "Provide a valid project name and directory!"
            QMessageBox.warning(
                None, "Invalid information provided", result, QMessageBox.Ok)
            return

    #### pedro
    # self.dlg_flow_tt.le_6_pg1.setText("90")    # Leste
    # self.dlg_flow_tt.le_5_pg1.setText("45")    # Nordeste
    # self.dlg_flow_tt.le_12_pg1.setText("360")  # Norte
    # self.dlg_flow_tt.le_11_pg1.setText("315")  # Noroeste
    # self.dlg_flow_tt.le_10_pg1.setText("270")  # Oeste
    # self.dlg_flow_tt.le_9_pg1.setText("225")   # Sudoeste
    # self.dlg_flow_tt.le_8_pg1.setText("180")   # Sul
    # self.dlg_flow_tt.le_7_pg1.setText("135")   # Sudeste

    def atualizar_label_validacao(self, label, status):
        """
        Atualiza o texto de um label de validação.

        Parâmetros:
        - label: QLabel (ex.: self.dlg_flow_tt.label_81)
        - status: str ('ok', 'erro', 'nao_selecionado')

        Comportamento:
        - ok:       label recebe '✅ Validated'
        - erro:     label recebe '❌ Invalid'
        - nao_selecionado: label recebe '⚠️ Not selected'
        """
        if status == 'ok':
            label.setText("✅ Validated")
        elif status == 'erro':
            label.setText("❌ Invalid")
        elif status == 'nao_selecionado':
            label.setText("⚠️ Not selected")
        else:
            label.setText(status)  # Permite texto personalizado se desejar


    def get_raster_info(self, path):
        """
        Abre o raster e retorna:
        (nlin, ncol, resx, resy)
        """

        layer = self.get_raster_layer_by_name(path)
        provider = layer.dataProvider()
        extent = layer.extent()
        ncol = layer.width()
        nlin = layer.height()
        resx = extent.width() / ncol
        resy = extent.height() / nlin
        return nlin, ncol, resx, resy


    def raster_to_array(self, raster_layer):
        provider = raster_layer.dataProvider()
        extent = raster_layer.extent()
        width = raster_layer.width()
        height = raster_layer.height()
        band = 1

        block = provider.block(band, extent, width, height)
        if not block or block.isEmpty():
            raise RuntimeError("Falha ao ler bloco raster.")

        array = block.as_numpy()
        return array

    def get_raster_layer_by_name(self, name):
        # Busca no projeto QGIS um layer cujo nome (layer.name()) é igual a 'name'
        for layer in QgsProject.instance().mapLayers().values():
            if layer.name() == name:
                return layer
        raise ValueError(f"Raster '{name}' não encontrado no projeto.")

    def validar_raster_bacia(self, path, modulo=1):
        """
        Valida se o raster da bacia contém apenas valores 0 e 1.

        Parâmetros:
        - path: nome da camada selecionada no combobox
        - modulo: int, define qual label será atualizado:
            - 1: label_81
            - 2: label_17
            - 3: label_14
        """
        try:
            if modulo == 1:
                label = self.dlg_flow_tt.label_81
            elif modulo == 2:
                label = self.dlg_exc_rain.label_17
            elif modulo == 3:
                label = self.dlg_flow_rout.label_14
            else:
                QMessageBox.warning(self.dlg_flow_tt, "Aviso", f"Módulo inválido: {modulo}")
                return

            if not path:
                self.atualizar_label_validacao(label, 'nao_selecionado')
                return

            layer = self.get_raster_layer_by_name(path)
            array = self.raster_to_array(layer)

            valores_unicos = np.unique(array)
            if not np.all(np.isin(valores_unicos, [0, 1])):
                QMessageBox.critical(
                    self.dlg_flow_tt,
                    "Erro",
                    f"Raster de bacia contém valores diferentes de 0 e 1.\nValores encontrados: {valores_unicos}"
                )
                self.atualizar_label_validacao(label, 'erro')
                return

            QMessageBox.information(self.dlg_flow_tt, "OK", "Raster de bacia válido.")
            self.atualizar_label_validacao(label, 'ok')

        except Exception as e:
            QMessageBox.critical(self.dlg_flow_tt, "Erro inesperado", str(e))
            self.atualizar_label_validacao(label, 'erro')


    def validar_raster_mde(self):
        try:
            nome = self.dlg_flow_tt.cb_2_pg2.currentText()
            if not nome:
                self.atualizar_label_validacao(self.dlg_flow_tt.label_82, 'nao_selecionado')
                return

            layer = self.get_raster_layer_by_name(nome)
            array = self.raster_to_array(layer)

            if np.any(array < 0):
                QMessageBox.critical(self.dlg_flow_tt, "Erro", "MDE inválido: contém valores negativos.")
                self.atualizar_label_validacao(self.dlg_flow_tt.label_82, 'erro')
                return

            QMessageBox.information(self.dlg_flow_tt, "OK", "MDE válido: não há valores negativos.")
            self.atualizar_label_validacao(self.dlg_flow_tt.label_82, 'ok')

        except Exception as e:
            QMessageBox.critical(self.dlg_flow_tt, "Erro inesperado", str(e))
            self.atualizar_label_validacao(self.dlg_flow_tt.label_82, 'erro')

    
    def validar_fluxo_manual(self): 
        """
        Verify if the flow directions raster's values are valid
        """
        try:
            fluxo = self.dlg_flow_tt.cb_3_pg2.currentText()
            if not fluxo:
                self.atualizar_label_validacao(self.dlg_flow_tt.label_90, 'nao_selecionado')
                return

            if self.validar_direcoes(fluxo):
                QMessageBox.information(self.dlg_flow_tt, "OK", "Raster de direções válido.")
                self.atualizar_label_validacao(self.dlg_flow_tt.label_90, 'ok')
            else:
                QMessageBox.critical(self.dlg_flow_tt, "Erro", "Raster de direções inválido.")
                self.atualizar_label_validacao(self.dlg_flow_tt.label_90, 'erro')

        except Exception as e:
            QMessageBox.critical(self.dlg_flow_tt, "Erro inesperado", str(e))
            self.atualizar_label_validacao(self.dlg_flow_tt.label_90, 'erro')


    # deletar funcao quando parar de testar
    def preencher_direcoes_padrao(self):
        self.dlg_flow_tt.le_6_pg1.setText("90")     # Leste
        self.dlg_flow_tt.le_5_pg1.setText("45")     # Nordeste
        self.dlg_flow_tt.le_12_pg1.setText("360")   # Norte
        self.dlg_flow_tt.le_11_pg1.setText("315")   # Noroeste
        self.dlg_flow_tt.le_10_pg1.setText("270")   # Oeste
        self.dlg_flow_tt.le_9_pg1.setText("225")    # Sudoeste
        self.dlg_flow_tt.le_8_pg1.setText("180")    # Sul
        self.dlg_flow_tt.le_7_pg1.setText("135")    # Sudeste

    def check_all_equal(self, paths):
        """
        Verifica se todos os rasters em 'paths' têm:
        - mesmo número de linhas
        - mesmo número de colunas
        - mesma resolução X e Y
        """
        if not paths:
            return True  # ou False, dependendo do que preferir para lista vazia

        info0 = self.get_raster_info(paths[0])
        for p in paths[1:]:
            info = self.get_raster_info(p)
            if info != info0:
                return False
        return True

    def verificar_dimensoes_rasters(self, paths, modulo=1):
        """
        Verifica se todos os rasters fornecidos possuem a mesma dimensão e resolução.

        Parâmetros:
        - paths: lista de nomes de camadas raster selecionadas nos comboboxes
        - modulo: int (1, 2 ou 3) define qual label e dialog serão utilizados:
            - 1: dlg_flow_tt.label_95
            - 2: dlg_exc_rain.label_13
            - 3: dlg_flow_rout.label_10
        """
        paths = [p for p in paths if p]

        # Define o label e a janela (dlg) com base no módulo
        if modulo == 1:
            label = self.dlg_flow_tt.label_95
            dlg = self.dlg_flow_tt
        elif modulo == 2:
            label = self.dlg_exc_rain.label_13
            dlg = self.dlg_exc_rain
        elif modulo == 3:
            label = self.dlg_flow_rout.label_10
            dlg = self.dlg_flow_rout
        else:
            QMessageBox.warning(self.dlg_flow_tt, "Aviso", f"Módulo inválido: {modulo}")
            return

        if not paths:
            QMessageBox.warning(dlg, "Aviso", "Nenhum raster selecionado para validação.")
            self.atualizar_label_validacao(label, 'nao_selecionado')
            return

        if self.check_all_equal(paths):
            QMessageBox.information(dlg, "Validação", "Todos os rasters têm a mesma dimensão e resolução.")
            self.atualizar_label_validacao(label, 'ok')
        else:
            QMessageBox.critical(dlg, "Erro", "Os rasters possuem dimensões ou resoluções diferentes.")
            self.atualizar_label_validacao(label, 'erro')





    def validar_direcoes(self, fluxo_path):
        """
        Valida se todos os valores inseridos para direções no QLineEdit
        estão presentes no raster de fluxo e se não existem direções duplicadas.
        """
        layer = self.get_raster_layer_by_name(os.path.basename(fluxo_path))
        raster_fluxo_data = self.raster_to_array(layer)

        # Lê as direções inseridas na interface gráfica
        try:
            campos = {
                (0, 1):  self.dlg_flow_tt.le_6_pg1.text(),   # Leste
                (-1, 1): self.dlg_flow_tt.le_5_pg1.text(),   # Nordeste
                (-1, 0): self.dlg_flow_tt.le_12_pg1.text(),  # Norte
                (-1,-1): self.dlg_flow_tt.le_11_pg1.text(),  # Noroeste
                (0, -1): self.dlg_flow_tt.le_10_pg1.text(),  # Oeste
                (1, -1): self.dlg_flow_tt.le_9_pg1.text(),   # Sudoeste
                (1, 0):  self.dlg_flow_tt.le_8_pg1.text(),   # Sul
                (1, 1):  self.dlg_flow_tt.le_7_pg1.text(),   # Sudeste
            }

            # Verifica se há campos vazios
            for direcao, texto in campos.items():
                if texto.strip() == "":
                    raise ValueError(f"Campo vazio encontrado para a direção {direcao}")

            direcoes_dict = {k: int(v) for k, v in campos.items()}

        except ValueError as e:
            QMessageBox.critical(self.dlg_flow_tt, "Erro", f"Direção inválida: {e}")
            return False

        # Verifica se cada direção inserida está presente no raster de fluxo
        valores_no_raster = np.unique(raster_fluxo_data)

        for direcao in direcoes_dict.values():
            if direcao not in valores_no_raster:
                QMessageBox.critical(self.dlg_flow_tt, "Erro", f"A direção {direcao} não está presente no raster.")
                return False

        # Verifica se há direções duplicadas no dicionário
        direcoes_values = list(direcoes_dict.values())
        if len(direcoes_values) != len(set(direcoes_values)):
            QMessageBox.critical(self.dlg_flow_tt, "Erro", "Existem direções duplicadas. Cada direção deve ser única.")
            return False

        return True

    def encontrar_exutorio(self, raster_fluxo_data, raster_bacia_data, raster_acumulado_data):
        nlin, ncol = raster_bacia_data.shape

        max_valor = -np.inf
        exutorio = None

        for i in range(nlin):
            for j in range(ncol):
                if raster_bacia_data[i, j] != 1:
                    continue

                valor_acumulado = raster_acumulado_data[i, j]
                if np.isnan(valor_acumulado):
                    continue

                if valor_acumulado > max_valor:
                    max_valor = valor_acumulado
                    exutorio = (i, j)

        if exutorio is None:
            QMessageBox.critical(self.dlg_flow_tt, "Erro", "Nenhum exutório encontrado: bacia sem valores acumulados válidos.")
            return None

        return exutorio


    def processar_fluxo(self):
        nome_raster_acumulado = self.dlg_flow_tt.cb_6_pg2.currentText()
        if not nome_raster_acumulado:
            QMessageBox.critical(self.dlg_flow_tt, "Erro", "Selecione o raster acumulado no combobox.")
            return

        raster_fluxo = self.dlg_flow_tt.cb_3_pg2.currentText()
        raster_bacia = self.dlg_flow_tt.cb_1_pg2.currentText()
        raster_acumulado = nome_raster_acumulado

        layer_fluxo = self.get_raster_layer_by_name(os.path.basename(raster_fluxo))
        layer_bacia = self.get_raster_layer_by_name(os.path.basename(raster_bacia))
        layer_acumulado = self.get_raster_layer_by_name(os.path.basename(raster_acumulado))

        raster_fluxo_data = self.raster_to_array(layer_fluxo)
        raster_fluxo_data = np.where(np.ma.getmaskarray(raster_fluxo_data), 0, raster_fluxo_data)

        raster_bacia_data = self.raster_to_array(layer_bacia)
        raster_bacia_data = np.where(np.ma.getmaskarray(raster_bacia_data), 0, raster_bacia_data)

        raster_acumulado_data = self.raster_to_array(layer_acumulado)
        raster_acumulado_data = np.where(np.ma.getmaskarray(raster_acumulado_data), np.nan, raster_acumulado_data)

        exutorio = self.encontrar_exutorio(raster_fluxo_data, raster_bacia_data, raster_acumulado_data)
        area_exutorio = None
        if exutorio is None:
            return

        nlin, ncol = raster_fluxo_data.shape

        direcoes_dict = {
            (0, 1):  int(self.dlg_flow_tt.le_6_pg1.text()),   # Leste
            (-1, 1): int(self.dlg_flow_tt.le_5_pg1.text()),   # Nordeste
            (-1, 0): int(self.dlg_flow_tt.le_12_pg1.text()),  # Norte
            (-1, -1): int(self.dlg_flow_tt.le_11_pg1.text()), # Noroeste
            (0, -1): int(self.dlg_flow_tt.le_10_pg1.text()),  # Oeste
            (1, -1): int(self.dlg_flow_tt.le_9_pg1.text()),   # Sudoeste
            (1, 0):  int(self.dlg_flow_tt.le_8_pg1.text()),   # Sul
            (1, 1):  int(self.dlg_flow_tt.le_7_pg1.text()),   # Sudeste
        }
        angulo_para_vetor = {ang: vec for vec, ang in direcoes_dict.items()}

        def dentro(i, j):
            return 0 <= i < nlin and 0 <= j < ncol

        if not (dentro(*exutorio) and raster_bacia_data[exutorio] == 1):
            QMessageBox.critical(self.dlg_flow_tt, "Erro", "Exutório inválido ou fora da bacia.")
            return

        status = np.full_like(raster_bacia_data, -1, dtype=np.int8)

        for i in range(nlin):
            for j in range(ncol):
                if raster_bacia_data[i, j] != 1 or status[i, j] != -1:
                    continue

                pilha = [(i, j)]
                visitando = set()
                caminho = []
                ultimo = (i, j)

                while pilha:
                    ci, cj = pilha[-1]
                    ultimo = (ci, cj)

                    if (ci, cj) in visitando:
                        for pi, pj in pilha:
                            status[pi, pj] = 0
                        break

                    visitando.add((ci, cj))
                    caminho.append((ci, cj))

                    if (ci, cj) == exutorio:
                        area_exutorio = raster_acumulado_data[exutorio]
                        for pi, pj in caminho:
                            status[pi, pj] = 1
                        break

                    flux = raster_fluxo_data[ci, cj]
                    vec = angulo_para_vetor.get(flux)
                    if vec is None:
                        for pi, pj in caminho:
                            status[pi, pj] = 0
                        break

                    ni, nj = ci + vec[0], cj + vec[1]
                    if not (dentro(ni, nj) and raster_bacia_data[ni, nj] == 1):
                        for pi, pj in caminho:
                            status[pi, pj] = 0
                        break

                    s = status[ni, nj]
                    if s == 1:
                        for pi, pj in caminho:
                            status[pi, pj] = 1
                        break
                    if s == 0 or (ni, nj) in visitando:
                        for pi, pj in caminho:
                            status[pi, pj] = 0
                        break

                    pilha.append((ni, nj))

                if status[i, j] == 0:
                    msgs = [
                        "ERRO: pelo menos um pixel não convergiu.",
                        f"Pixel inicial: ({i}, {j})",
                        f"Último pixel válido: {ultimo}",
                        f"Exutório é: {exutorio}"
                    ]
                    QMessageBox.critical(self.dlg_flow_tt, "Falha de Convergência", "\n".join(msgs))
                    return

        QMessageBox.information(
            self.dlg_flow_tt, 
            "Sucesso", 
            f"Todos os pixels da bacia convergiram para o exutório {exutorio}." \
            f"\nÁrea acumulada no exutório: {area_exutorio:.2f}.") 


    def executar_validacao_fluxo(self):
        self.preencher_direcoes_padrao()

        nome_fluxo = self.dlg_flow_tt.cb_3_pg2.currentText()
        nome_bacia = self.dlg_flow_tt.cb_1_pg2.currentText()
        nome_acumulado = self.dlg_flow_tt.cb_6_pg2.currentText()

        if not (nome_fluxo and nome_bacia and nome_acumulado):
            QMessageBox.critical(self.dlg_flow_tt, "Erro", "Selecione os rasters de fluxo, bacia e acumulado.")
            self.atualizar_label_validacao(self.dlg_flow_tt.label_94, 'nao_selecionado')
            return

        try:
            self.processar_fluxo()
            self.atualizar_label_validacao(self.dlg_flow_tt.label_94, 'ok')

        except Exception as e:
            QMessageBox.critical(self.dlg_flow_tt, "Erro inesperado", str(e))
            self.atualizar_label_validacao(self.dlg_flow_tt.label_94, 'erro')

    def validar_uso_cobertura(self):
        try:
            raster_bacia_nome = self.dlg_flow_tt.cb_1_pg2.currentText()
            raster_uso_nome = self.dlg_flow_tt.cb_7_pg2.currentText()

            layer_bacia = self.get_raster_layer_by_name(raster_bacia_nome)
            layer_uso = self.get_raster_layer_by_name(raster_uso_nome)

            array_bacia = self.raster_to_array(layer_bacia)
            array_uso = self.raster_to_array(layer_uso)

            array_bacia = np.where(np.ma.getmaskarray(array_bacia), 0, array_bacia)
            mask_bacia = array_bacia == 1

            array_uso = np.where(np.ma.getmaskarray(array_uso), -9999, array_uso)

            valores_uso = array_uso[mask_bacia]
            valores_unicos = np.unique(valores_uso)

            valores_validos = [v for v in valores_unicos if isinstance(v, (int, np.integer)) and v != 0 and v != -9999]

            if len(valores_validos) != len(valores_unicos):
                self.dlg_flow_tt.label_99.setText("❌ Inválido")
                QMessageBox.critical(self.dlg_flow_tt, "Erro", "Raster de uso e cobertura contém valores inválidos dentro da bacia.")
                return

            self.classes_uso_validas = set(valores_validos)
            self.dlg_flow_tt.label_99.setText("✅ Válido")

        except Exception as e:
            self.dlg_flow_tt.label_99.setText("❌ Erro")
            QMessageBox.critical(self.dlg_flow_tt, "Erro inesperado", str(e))

    def validar_tabela_manning(self):
        try:
            if not hasattr(self, "classes_uso_validas") or not self.classes_uso_validas:
                QMessageBox.warning(self.dlg_flow_tt, "Aviso", "Execute a validação do raster de uso e cobertura primeiro.")
                self.dlg_flow_tt.label_97.setText("⚠️ Aguardando validação anterior")
                return

            tabela = self.dlg_flow_tt.tbw_2_pg2
            linhas = tabela.rowCount()

            classes_tabela = set()
            manning_validos = {}

            for i in range(linhas):
                try:
                    classe_id = int(tabela.item(i, 0).text())
                    manning = float(tabela.item(i, 2).text())
                    classes_tabela.add(classe_id)
                    manning_validos[classe_id] = manning
                except:
                    continue

            faltando = self.classes_uso_validas - classes_tabela
            manning_invalidos = [cid for cid in self.classes_uso_validas if manning_validos.get(cid, 0) <= 0]

            if faltando or manning_invalidos:
                self.dlg_flow_tt.label_97.setText("❌ Inválido")
                QMessageBox.critical(self.dlg_flow_tt, "Erro", "A tabela não contém todos os valores de Manning válidos para as classes encontradas.")
            else:
                self.dlg_flow_tt.label_97.setText("✅ Válido")

        except Exception as e:
            self.dlg_flow_tt.label_97.setText("❌ Erro")
            QMessageBox.critical(self.dlg_flow_tt, "Erro inesperado", str(e))

    def verificar_conectividade_rede(self):
        nome_rede = self.dlg_flow_tt.cb_4_pg2.currentText()
        camada_rede = self.get_raster_layer_by_name(nome_rede)

        if not camada_rede:
            QMessageBox.critical(self.dlg_flow_tt, "Erro", "Camada de rede de drenagem não encontrada.")
            self.atualizar_label_validacao(self.dlg_flow_tt.label_103, 'nao_selecionado')
            return

        rede_data = self.raster_to_array(camada_rede)

        exutorio = None
        nlin, ncol = rede_data.shape
        for i in range(nlin):
            for j in range(ncol):
                if rede_data[i, j] == 1:
                    exutorio = (i, j)
        if exutorio is None:
            QMessageBox.critical(self.dlg_flow_tt, "Erro", "Nenhum pixel de rede encontrado.")
            self.atualizar_label_validacao(self.dlg_flow_tt.label_103, 'erro')
            return

        visitado = np.zeros_like(rede_data, dtype=bool)
        
        fila = deque()
        fila.append(exutorio)
        visitado[exutorio] = True

        vizinhos = [(-1, -1), (-1, 0), (-1, 1),
                    (0, -1),          (0, 1),
                    (1, -1), (1, 0),  (1, 1)]

        while fila:
            i, j = fila.popleft()
            for di, dj in vizinhos:
                ni, nj = i + di, j + dj
                if 0 <= ni < nlin and 0 <= nj < ncol:
                    if not visitado[ni, nj] and rede_data[ni, nj] == 1:
                        visitado[ni, nj] = True
                        fila.append((ni, nj))

        for i in range(nlin):
            for j in range(ncol):
                if rede_data[i, j] == 1 and not visitado[i, j]:
                    QMessageBox.critical(
                        self.dlg_flow_tt,
                        "Erro",
                        f"Pixel da rede ({i}, {j}) não está conectado ao exutório."
                    )
                    self.atualizar_label_validacao(self.dlg_flow_tt.label_103, 'erro')
                    return

        QMessageBox.information(
            self.dlg_flow_tt,
            "Sucesso",
            "Todos os pixels da rede estão conectados ao exutório."
        )
        self.atualizar_label_validacao(self.dlg_flow_tt.label_103, 'ok')

    def verificar_acumulado_drenagem(self):
        from collections import deque

        # Obtém caminhos dos rasters
        path_acumulado = self.dlg_flow_tt.cb_6_pg2.currentText()
        path_bacia = self.dlg_flow_tt.cb_1_pg2.currentText()
        path_rede = self.dlg_flow_tt.cb_4_pg2.currentText()

        # Verifica se foram selecionados
        if not path_acumulado or not path_bacia or not path_rede:
            QMessageBox.warning(self.dlg_flow_tt, "Aviso", "Um ou mais rasters não foram selecionados.")
            self.atualizar_label_validacao(self.dlg_flow_tt.label_105, 'nao_selecionado')
            return

        # Lê os dados
        acumulado_layer = self.get_raster_layer_by_name(path_acumulado)
        acumulado_data = self.raster_to_array(acumulado_layer)

        bacia_layer = self.get_raster_layer_by_name(path_bacia)
        bacia_data = self.raster_to_array(bacia_layer)

        rede_layer = self.get_raster_layer_by_name(path_rede)
        rede_data = self.raster_to_array(rede_layer)

        # Encontrar o exutório
        exutorio = self.encontrar_exutorio(None, bacia_data, acumulado_data)
        if exutorio is None:
            self.atualizar_label_validacao(self.dlg_flow_tt.label_105, 'erro')
            return

        nlin, ncol = bacia_data.shape
        visitado = np.zeros((nlin, ncol), dtype=bool)
        fila = deque()

        # Inicializa com o exutório
        fila.append(exutorio)
        visitado[exutorio] = True

        # Direções vizinhas (8 conectividades)
        direcoes = [(-1, -1), (-1, 0), (-1, 1),
                    (0, -1),          (0, 1),
                    (1, -1),  (1, 0), (1, 1)]

        while fila:
            i, j = fila.popleft()
            val_atual = acumulado_data[i, j]

            for di, dj in direcoes:
                ni, nj = i + di, j + dj
                if 0 <= ni < nlin and 0 <= nj < ncol:
                    if visitado[ni, nj]:
                        continue
                    if bacia_data[ni, nj] != 1:
                        continue
                    if rede_data[ni, nj] != 1:
                        continue
                    val_vizinho = acumulado_data[ni, nj]

                    if np.isnan(val_vizinho) or val_vizinho <= 0:
                        QMessageBox.critical(self.dlg_flow_tt, "Erro", f"Pixel inválido ({ni}, {nj}) com valor acumulado {val_vizinho}")
                        self.atualizar_label_validacao(self.dlg_flow_tt.label_105, 'erro')
                        return

                    # Validação: deve ser menor que o atual para ser montante
                    if val_vizinho < val_atual:
                        visitado[ni, nj] = True
                        fila.append((ni, nj))

        # Verifica se todos os pixels da rede foram visitados
        for i in range(nlin):
            for j in range(ncol):
                if bacia_data[i, j] == 1 and rede_data[i, j] == 1:
                    if not visitado[i, j]:
                        QMessageBox.critical(
                            self.dlg_flow_tt, "Erro",
                            f"Pixel da rede ({i}, {j}) não está conectado corretamente ao exutório ou tem valores não crescentes."
                        )
                        self.atualizar_label_validacao(self.dlg_flow_tt.label_105, 'erro')
                        return

        # Sucesso
        QMessageBox.information(self.dlg_flow_tt, "Validação", "Todos os valores acumulados estão corretos e crescentes até o exutório.")
        self.atualizar_label_validacao(self.dlg_flow_tt.label_105, 'ok')


    # pedro rain
    def validar_raster_cn(self):
        try:
            # Caminhos dos rasters
            path_cn = self.dlg_exc_rain.cb_2_pg2.currentText()
            path_bacia = self.dlg_exc_rain.cb_1_pg2.currentText()

            if not path_cn or not path_bacia:
                self.atualizar_label_validacao(self.dlg_exc_rain.label_19, 'nao_selecionado')
                return

            # Carrega as camadas
            layer_cn = self.get_raster_layer_by_name(path_cn)
            layer_bacia = self.get_raster_layer_by_name(path_bacia)

            # Converte para arrays
            cn_data = self.raster_to_array(layer_cn)
            bacia_data = self.raster_to_array(layer_bacia)

            # Validação de dimensão
            if cn_data.shape != bacia_data.shape:
                QMessageBox.critical(self.dlg_exc_rain, "Erro", "As dimensões do raster de CN e da bacia não coincidem.")
                self.atualizar_label_validacao(self.dlg_exc_rain.label_19, 'erro')
                return

            # Aplica a máscara da bacia
            mascara_bacia = bacia_data == 1
            cn_dentro_bacia = cn_data[mascara_bacia]

            # Verificação
            if np.any(np.isnan(cn_dentro_bacia)):
                QMessageBox.critical(self.dlg_exc_rain, "Erro", "O raster de CN contém valores NaN dentro da bacia.")
                self.atualizar_label_validacao(self.dlg_exc_rain.label_19, 'erro')
                return

            if np.any((cn_dentro_bacia <= 0) | (cn_dentro_bacia > 100)):
                valores_invalidos = cn_dentro_bacia[(cn_dentro_bacia <= 0) | (cn_dentro_bacia > 100)]
                QMessageBox.critical(
                    self.dlg_exc_rain,
                    "Erro",
                    f"O raster de CN possui valores inválidos dentro da bacia. Exemplos: {valores_invalidos[:5]}"
                )
                self.atualizar_label_validacao(self.dlg_exc_rain.label_19, 'erro')
                return

            # Tudo OK
            QMessageBox.information(self.dlg_exc_rain, "Validação", "Raster de CN válido.")
            self.atualizar_label_validacao(self.dlg_exc_rain.label_19, 'ok')

        except Exception as e:
            QMessageBox.critical(self.dlg_exc_rain, "Erro inesperado", str(e))
            self.atualizar_label_validacao(self.dlg_exc_rain.label_19, 'erro')

    # pedro flow routing
    def verificar_tempos_de_viagem(self):
        try:
            # Obter caminhos dos rasters
            nome_tempo = self.dlg_flow_rout.cb_3_pg2.currentText()
            nome_bacia = self.dlg_flow_rout.cb_1_pg2.currentText()
            nome_rede = self.dlg_flow_rout.cb_2_pg2.currentText()
            nome_fluxo = self.dlg_flow_tt.cb_3_pg2.currentText()  # Direções de fluxo

            if not nome_tempo or not nome_bacia or not nome_fluxo:
                self.atualizar_label_validacao(self.dlg_flow_rout.label_20, 'nao_selecionado')
                return

            # Carregar arrays
            tempo_array = self.raster_to_array(self.get_raster_layer_by_name(nome_tempo))
            bacia_array = self.raster_to_array(self.get_raster_layer_by_name(nome_bacia))
            fluxo_array = self.raster_to_array(self.get_raster_layer_by_name(nome_fluxo))

            rede_array = None
            if nome_rede:
                try:
                    rede_array = self.raster_to_array(self.get_raster_layer_by_name(nome_rede))
                except:
                    pass  # Considera sem rede se erro

            nlin, ncol = bacia_array.shape

            # Mapeamento das direções D8 (valores comuns: 1 a 128)
            direcoes_d8 = {
                1:  (0, 1),    # Leste
                2:  (1, 1),    # Sudeste
                4:  (1, 0),    # Sul
                8:  (1, -1),   # Sudoeste
                16: (0, -1),   # Oeste
                32: (-1, -1),  # Noroeste
                64: (-1, 0),   # Norte
                128:(-1, 1)    # Nordeste
            }

            visitado = np.zeros_like(bacia_array, dtype=bool)

            def seguir_fluxo(i, j):
                caminho = [(i, j)]
                while True:
                    if not (0 <= i < nlin and 0 <= j < ncol):
                        return True  # Fora dos limites → final

                    if bacia_array[i, j] != 1:
                        return True  # Fora da bacia → final

                    if visitado[i, j]:
                        return True  # Já validado

                    if not np.isfinite(tempo_array[i, j]) or tempo_array[i, j] <= 0:
                        return False  # Valor inválido

                    if rede_array is not None and rede_array[i, j] != 1:
                        return True  # Fora da rede

                    direcao = fluxo_array[i, j]
                    if direcao not in direcoes_d8:
                        return True  # Sem direção válida (possivelmente exutório)

                    di, dj = direcoes_d8[direcao]
                    ni, nj = i + di, j + dj

                    if not (0 <= ni < nlin and 0 <= nj < ncol):
                        return True  # Fora da grade

                    tempo_atual = tempo_array[i, j]
                    tempo_prox = tempo_array[ni, nj]

                    if np.isfinite(tempo_prox) and tempo_prox < tempo_atual:
                        return False  # Não está crescendo

                    visitado[i, j] = True
                    i, j = ni, nj
                    caminho.append((i, j))

            # Verificar todos os pixels da bacia (e rede, se houver)
            for i in range(nlin):
                for j in range(ncol):
                    if bacia_array[i, j] == 1 and not visitado[i, j]:
                        if rede_array is None or rede_array[i, j] == 1:
                            if not seguir_fluxo(i, j):
                                QMessageBox.critical(self.dlg_flow_rout, "Erro",
                                    f"Tempo de viagem inválido: valores não positivos ou não crescentes a partir de ({i}, {j}).")
                                self.atualizar_label_validacao(self.dlg_flow_rout.label_20, 'erro')
                                return

            QMessageBox.information(self.dlg_flow_rout, "Validação", "Raster de tempo de viagem válido.")
            self.atualizar_label_validacao(self.dlg_flow_rout.label_20, 'ok')

        except Exception as e:
            QMessageBox.critical(self.dlg_flow_rout, "Erro inesperado", str(e))
            self.atualizar_label_validacao(self.dlg_flow_rout.label_20, 'erro')







    def run(self):
        """Esta é a função principal do plugin, todas as funcionalidades propostas anteriormente serão efetivadas na função run"""

        self.dlg_hidro_pixel = HidroPixelDialog()
        # self.dlg_hidro_pixel.setWindowModality(Qt.ApplicationModal)

        # Verifica se a interface já foi mostrada anteriormente
        if not hasattr(self, 'dlg_hidro_pixel') or not self.dlg_hidro_pixel.isVisible():
            # Adiciona logo Hidropixel na pagina incial
            caminho_icon = os.path.abspath(
                self.diretorio_atual + r"/icons/logo_menu.png")
            pixmap = QPixmap(caminho_icon)

            # Configurando a imagem na QLabel
            self.dlg_hidro_pixel.label_2.setPixmap(pixmap)
            self.dlg_hidro_pixel.label_2.setScaledContents(True)

            # Inicializa self.dlg_hidro_pixel apenas se ainda não estiver inicializado ou se estiver fechado
            # Mostra a interface gráfica
            self.dlg_hidro_pixel.show()
            QApplication.processEvents()

            # Desativa a página de log, só será ativada após clicar no botão run
            self.dlg_flow_tt.pg_log_ftt.setEnabled(False)
            # Cria as flags para configurar a leitura dos dados da tabela
            self.flag = 0
            self.flag_1 = 0

            # Configura botão about
            self.dlg_hidro_pixel.btn_flow_about.clicked.connect(
                lambda: self.dlg_about.show())

            # Chama funcao que aplica mascara para todos os parametros das diferentes rotinas
            self.parameters_mask()

            # Configura botões do menu do hidropixel e estilo dos botoes da configuration page
            self.dlg_hidro_pixel.btn_flow_trav.clicked.connect(
                lambda: self.dlg_flow_tt.show())
            self.dlg_flow_tt.btn_config.setStyleSheet(self.highlighted_style)

            self.dlg_hidro_pixel.btn_exes_rain.clicked.connect(
                lambda: self.dlg_exc_rain.show())
            self.dlg_exc_rain.btn_config.setStyleSheet(self.highlighted_style)

            self.dlg_hidro_pixel.btn_flow_rout.clicked.connect(
                lambda: self.dlg_flow_rout.show())
            self.dlg_flow_rout.btn_config.setStyleSheet(self.highlighted_style)

            # self.dlg_hidro_pixel.btn_help.clicked.connect()
            '''Configura os botões da página da rotina do flow travel time'''
            # Conecte os botões à função de destaque

            
            # Chama páginas da GUI e função de mudanca de estilo dos botoes
            self.dlg_flow_tt.btn_config.clicked.connect(
                lambda: self.SsButoes(self.dlg_flow_tt.btn_config, self.dlg_flow_tt))
            self.dlg_flow_tt.btn_config.clicked.connect(
                lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg1_config))

            self.dlg_flow_tt.btn_input_data.clicked.connect(
                lambda: self.SsButoes(self.dlg_flow_tt.btn_input_data, self.dlg_flow_tt))
            self.dlg_flow_tt.btn_input_data.clicked.connect(
                lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg2_in_data))

            self.dlg_flow_tt.btn_data_va_tool.clicked.connect(
                lambda: self.SsButoes(self.dlg_flow_tt.btn_data_va_tool, self.dlg_flow_tt))
            self.dlg_flow_tt.btn_data_va_tool.clicked.connect(
                lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg3_data_val_tool))

            self.dlg_flow_tt.btn_run.clicked.connect(
                lambda: self.SsButoes(self.dlg_flow_tt.btn_run, self.dlg_flow_tt))
            self.dlg_flow_tt.btn_run.clicked.connect(
                lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg4_run))

            # Configura os botões da página configuration: flow travel time
            self.dlg_flow_tt.tbtn_pg1_1.clicked.connect(
                lambda: self.carrega_work_folder(self.dlg_flow_tt.le_21_pg1))

            # Configura comboboxes para receber rasters do projeto QGIS

            self.carrega_rasters()
            # self.dlg_flow_tt.cb_1_pg1.toggled.connect(lambda: self.sheet_flow_status(self.dlg_flow_tt.cb_1_pg1.isChecked()))

            # Configura os botões da página input data : flow travel time
            self.dlg_flow_tt.tbtn_pg2_1.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_tt.cb_1_pg2))
            self.dlg_flow_tt.tbtn_pg2_2.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_tt.cb_2_pg2))
            self.dlg_flow_tt.tbtn_pg2_3.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_tt.cb_3_pg2))
            self.dlg_flow_tt.tbtn_pg2_4.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_tt.cb_4_pg2))
            self.dlg_flow_tt.tbtn_pg2_5.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_tt.cb_5_pg2))
            self.dlg_flow_tt.tbtn_pg2_6.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_tt.cb_7_pg2))
            self.dlg_flow_tt.tbtn_pg2_9.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_tt.cb_6_pg2))

            # Configura os botões da página data validation tool: flow travel time
            ### pedro

            self.dlg_flow_tt.pbtn_6_pg3.clicked.connect(
                lambda: self.validar_raster_bacia(self.dlg_flow_tt.cb_1_pg2.currentText(),modulo=1)
            )
            self.dlg_flow_tt.pbtn_7_pg3.clicked.connect(self.validar_raster_mde)
            self.dlg_flow_tt.pbtn_8_pg3.clicked.connect(self.preencher_direcoes_padrao)
            self.dlg_flow_tt.pbtn_8_pg3.clicked.connect(self.validar_fluxo_manual)
            self.dlg_flow_tt.pbtn_10_pg3.clicked.connect(lambda: self.verificar_dimensoes_rasters([
                        self.dlg_flow_tt.cb_1_pg2.currentText(),
                        self.dlg_flow_tt.cb_2_pg2.currentText(),
                        self.dlg_flow_tt.cb_3_pg2.currentText(),
                        self.dlg_flow_tt.cb_7_pg2.currentText()
                    ], modulo = 1)
                )
            self.dlg_flow_tt.pbtn9_pg3.clicked.connect(lambda: self.executar_validacao_fluxo())
            self.dlg_flow_tt.pbtn11_pg3.clicked.connect(self.validar_uso_cobertura)
            self.dlg_flow_tt.pbtn12_pg3.clicked.connect(self.validar_tabela_manning)
            self.dlg_flow_tt.pbtn14_pg3.clicked.connect(self.verificar_conectividade_rede)
            self.dlg_flow_tt.pbtn15_pg3.clicked.connect(self.verificar_acumulado_drenagem)


            # Configura os botões da página run page: flow travel time
            self.dlg_flow_tt.tbtn_pg4_6.clicked.connect(
                lambda: self.save_buttons(self.dlg_flow_tt.le_6_pg4))
            self.dlg_flow_tt.tbtn_pg4_7.clicked.connect(
                lambda: self.save_buttons(self.dlg_flow_tt.le_7_pg4))
            self.dlg_flow_tt.tbtn_pg4_8.clicked.connect(
                lambda: self.save_buttons(self.dlg_flow_tt.le_8_pg4, file_type='text'))
            self.dlg_flow_tt.tbtn_pg4_9.clicked.connect(
                lambda: self.save_buttons(self.dlg_flow_tt.le_9_pg4))
            self.dlg_flow_tt.tbtn_pg4_10.clicked.connect(
                lambda: self.save_buttons(self.dlg_flow_tt.le_10_pg4))
            self.dlg_flow_tt.tbtn_pg4_11.clicked.connect(
                lambda: self.save_buttons(self.dlg_flow_tt.le_11_pg4))

            # configura botões de salvar e salvar para um arquivo: flow travel time
            self.dlg_flow_tt.btn_save_file_pg1.clicked.connect(
                lambda: self.dlg_save_project_flow_tt.show())
            self.dlg_flow_tt.btn_save_file_pg2.clicked.connect(
                lambda: self.dlg_save_project_flow_tt.show())
            self.dlg_flow_tt.btn_save_file_pg4.clicked.connect(
                lambda: self.dlg_save_project_flow_tt.show())

            # Configura logica dos outputs ligados ao metodo das curvas regionais
            # River cros-sectional area
            self.dlg_flow_tt.ch_9_pg4.setEnabled(False)
            self.dlg_flow_tt.label_87.setEnabled(False)
            self.dlg_flow_tt.le_9_pg4.setEnabled(False)
            self.dlg_flow_tt.ch_20_pg4.setEnabled(False)
            self.dlg_flow_tt.tbtn_pg4_9.setEnabled(False)
            self.dlg_flow_tt.label_86.setEnabled(False)

            # River bankfull width
            self.dlg_flow_tt.ch_10_pg4.setEnabled(False)
            self.dlg_flow_tt.label_89.setEnabled(False)
            self.dlg_flow_tt.le_10_pg4.setEnabled(False)
            self.dlg_flow_tt.tbtn_pg4_10.setEnabled(False)
            self.dlg_flow_tt.label_88.setEnabled(False)
            self.dlg_flow_tt.ch_21_pg4.setEnabled(False)
            self.dlg_flow_tt.groupBox_3.toggled.connect(
                lambda: self.reginal_curve_condition())

            # configura gui save to project para criar projeto da flow travel time
            self.dlg_save_project_flow_tt.tbtn_path.clicked.connect(
                lambda: self.get_project_dir(self.dlg_save_project_flow_tt))
            self.dlg_save_project_flow_tt.btn_save_project.clicked.connect(
                lambda: self.run_save_project(self.dlg_save_project_flow_tt, 1))

            # Configura botão para ler informações de um arquivo enviado : flow travel time
            self.dlg_flow_tt.btn_read_pg1.clicked.connect(
                lambda: self.read_from_project(1, self.dlg_flow_tt.le_21_pg1.text()))
            self.dlg_flow_tt.btn_read_pg2.clicked.connect(
                lambda: self.read_from_project(1, self.dlg_flow_tt.le_21_pg1.text()))
            self.dlg_flow_tt.btn_read_pg4.clicked.connect(
                lambda: self.read_from_project(1, self.dlg_flow_tt.le_21_pg1.text()))

            # Configura botões das tabelas : flow travel time
            self.dlg_flow_tt.btn_read_t1.clicked.connect(lambda: self.read_tb_from_file(
                self.dlg_flow_tt.tbw_1_pg2, self.dlg_flow_tt.le_8_pg2, 1))
            self.dlg_flow_tt.btn_read_t2.clicked.connect(lambda: self.read_tb_from_file(
                self.dlg_flow_tt.tbw_2_pg2, self.dlg_flow_tt.le_10_pg2, 2))
            self.dlg_flow_tt.btn_save_file_t1.clicked.connect(
                lambda: self.save_table_to_file_btn(1))
            self.dlg_flow_tt.btn_save_file_t2.clicked.connect(
                lambda: self.save_table_to_file_btn(2))
            self.dlg_flow_tt.btn_add_row_1.clicked.connect(
                lambda: self.add_new_row(self.dlg_flow_tt.tbw_1_pg2))
            self.dlg_flow_tt.btn_add_row_2.clicked.connect(
                lambda: self.add_new_row(self.dlg_flow_tt.tbw_2_pg2))
            self.dlg_flow_tt.btn_del_row_1.clicked.connect(
                lambda: self.delete_row(self.dlg_flow_tt.tbw_1_pg2))
            self.dlg_flow_tt.btn_del_row_2.clicked.connect(
                lambda: self.delete_row(self.dlg_flow_tt.tbw_2_pg2))

            # Configura os botões de limpeza das variáveis : flow travel time
            self.dlg_flow_tt.btn_clear_1.clicked.connect(lambda: self.clear_table(
                self.dlg_flow_tt.tbw_1_pg2, self.dlg_flow_tt.le_8_pg2))
            self.dlg_flow_tt.btn_clear_2.clicked.connect(lambda: self.clear_table(
                self.dlg_flow_tt.tbw_2_pg2, self.dlg_flow_tt.le_10_pg2))

            # configura botões da página run : flow travel time
            self.dlg_flow_tt.btn_close_pg4.clicked.connect(
                lambda: self.close_gui(1))

            # Configura run button : flow travel time
            # Configura condição para chamar rotinas em vb
            self.dlg_flow_tt.btn_run_2.clicked.connect(
                lambda: self.CondicaoRunFlowTT())

            # Configura botão que salva projeto da rotina flow travel time
            # Configura botões página de log: flow travel time
            self.dlg_flow_tt.btn_close_log.clicked.connect(
                lambda: self.close_gui(1))

            '''Configura os botões da página da rotina excess rainfall'''

            # Configura botões gerais das páginas da rotina excess rainfall e a função de mudança de estilo
            self.dlg_exc_rain.btn_config.clicked.connect(lambda: self.SsButoes(
                self.dlg_exc_rain.btn_config, self.dlg_exc_rain, page=1))
            self.dlg_exc_rain.btn_config.clicked.connect(
                lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg1_config))

            self.dlg_exc_rain.btn_rain_int.clicked.connect(lambda: self.SsButoes(
                self.dlg_exc_rain.btn_rain_int, self.dlg_exc_rain, page=1))
            self.dlg_exc_rain.btn_rain_int.clicked.connect(
                lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg2_rain_int))

            self.dlg_exc_rain.btn_input_data.clicked.connect(lambda: self.SsButoes(
                self.dlg_exc_rain.btn_input_data, self.dlg_exc_rain, page=1))
            self.dlg_exc_rain.btn_input_data.clicked.connect(
                lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg3_in_data))

            self.dlg_exc_rain.btn_data_va_tool.clicked.connect(lambda: self.SsButoes(
                self.dlg_exc_rain.btn_data_va_tool, self.dlg_exc_rain, page=1))
            self.dlg_exc_rain.btn_data_va_tool.clicked.connect(
                lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg4_data_val_tool))

            self.dlg_exc_rain.btn_run.clicked.connect(lambda: self.SsButoes(
                self.dlg_exc_rain.btn_run, self.dlg_exc_rain, page=1))
            self.dlg_exc_rain.btn_run.clicked.connect(
                lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg5_run))

            # Configura botões da página de configuration: excess rainfall
            self.dlg_exc_rain.tbtn_pg1_1.clicked.connect(
                lambda: self.carrega_work_folder(self.dlg_exc_rain.le_3_pg1))

            # Condição: usuário escolhe precipitação média (na bacia) ou destribuida (na bacia)
            self.dlg_exc_rain.le_4_pg2.setEnabled(False)
            self.dlg_exc_rain.label_32.setEnabled(False)
            self.dlg_exc_rain.tbtn_pg2_4.setEnabled(False)
            self.dlg_exc_rain.label_36.setEnabled(False)
            self.dlg_exc_rain.le_3_pg2.setEnabled(False)
            self.dlg_exc_rain.label_31.setEnabled(False)
            self.dlg_exc_rain.tbtn_pg2_3.setEnabled(False)
            self.dlg_exc_rain.label_35.setEnabled(False)

            # Se o usuário escolher a opção para chuva média
            self.dlg_exc_rain.rb_1_pg1.toggled.connect(
                lambda: self.rain_def_condition(1))
            self.dlg_exc_rain.rb_2_pg1.toggled.connect(
                lambda: self.rain_def_condition(2))

            # Configura os botões da página input data : excess rainfall
            self.dlg_exc_rain.tbtn_pg2_1.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_exc_rain.cb_1_pg2))
            self.dlg_exc_rain.tbtn_pg2_2.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_exc_rain.cb_2_pg2))
            self.dlg_exc_rain.tbtn_pg2_3.clicked.connect(
                lambda: self.carregaArquivos(self.dlg_exc_rain.le_3_pg2, 0, file_type='text'))
            self.dlg_exc_rain.tbtn_pg2_4.clicked.connect(
                lambda: self.carregaArquivos(self.dlg_exc_rain.le_4_pg2, 0, file_type='text'))
            

            # pedro
            self.dlg_exc_rain.pbtn1_pg_3.clicked.connect(lambda: self.verificar_dimensoes_rasters([
                        self.dlg_exc_rain.cb_1_pg2.currentText(),
                        self.dlg_exc_rain.cb_2_pg2.currentText(),
                    ], modulo = 2)
                )
            self.dlg_exc_rain.pbtn2_pg_3.clicked.connect(
                lambda: self.validar_raster_bacia(self.dlg_exc_rain.cb_1_pg2.currentText(),modulo=2)
            )
            self.dlg_exc_rain.pbtn3_pg_3.clicked.connect(self.validar_raster_cn)

            # configura botões de salvar e salvar para um arquivo: excess rainfall
            self.dlg_exc_rain.btn_save_file_pg1.clicked.connect(
                lambda: self.dlg_save_project_exc_rain.show())
            self.dlg_exc_rain.btn_save_file_pg_ri.clicked.connect(
                lambda: self.dlg_save_project_exc_rain.show())
            self.dlg_exc_rain.btn_save_file_pg2.clicked.connect(
                lambda: self.dlg_save_project_exc_rain.show())
            self.dlg_exc_rain.btn_save_file_pg4.clicked.connect(
                lambda: self.dlg_save_project_exc_rain.show())

            # configura gui save to project para criar projeto da excess rainfall
            self.dlg_save_project_exc_rain.tbtn_path.clicked.connect(
                lambda: self.get_project_dir(self.dlg_save_project_exc_rain))
            self.dlg_save_project_exc_rain.btn_save_project.clicked.connect(
                lambda: self.run_save_project(self.dlg_save_project_exc_rain, 2))

            # Configura botão para ler informações de uma arquivo enviado : excess rainfall
            self.dlg_exc_rain.btn_read_pg1.clicked.connect(
                lambda: self.read_from_project(2, self.dlg_exc_rain.le_3_pg1.text()))

            self.dlg_exc_rain.btn_read_pg_ri.clicked.connect(
                lambda: self.read_from_project(2, self.dlg_exc_rain.le_3_pg1.text()))
            self.dlg_exc_rain.btn_read_pg2.clicked.connect(
                lambda: self.read_from_project(2, self.dlg_exc_rain.le_3_pg1.text()))
            self.dlg_exc_rain.btn_read_pg4.clicked.connect(
                lambda: self.read_from_project(2, self.dlg_exc_rain.le_3_pg1.text()))

            # Configura os botões da página run page: excess rainfall
            self.dlg_exc_rain.tbtn_pg4_1.clicked.connect(
                lambda: self.save_buttons(self.dlg_exc_rain.le_1_pg4))
            self.dlg_exc_rain.tbtn_pg4_2.clicked.connect(
                lambda: self.save_buttons(self.dlg_exc_rain.le_2_pg4))
            self.dlg_exc_rain.tbtn_pg4_3.clicked.connect(
                lambda: self.save_buttons(self.dlg_exc_rain.le_3_pg4))
            self.dlg_exc_rain.tbtn_pg4_4.clicked.connect(
                lambda: self.save_buttons(self.dlg_exc_rain.le_4_pg4))
            self.dlg_exc_rain.tbtn_pg4_5.clicked.connect(
                lambda: self.save_buttons(self.dlg_exc_rain.le_5_pg4))
            self.dlg_exc_rain.tbtn_pg4_6.clicked.connect(
                lambda: self.save_buttons(self.dlg_exc_rain.le_6_pg4, file_type='text'))

            # configura botões da página run : excess rainfall
            # Configura condição para chamar rotinas em vb
            self.dlg_exc_rain.btn_run_2.clicked.connect(
                lambda: self.condicaoRunExcessRainfall())

            self.dlg_exc_rain.btn_close_pg4.clicked.connect(
                lambda: self.close_gui(2))

            # Configura botões da página rainfall interpolation
            self.dlg_exc_rain.tbtn_pg_r_1.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_exc_rain.cb_1_pg_ri))
            self.dlg_exc_rain.tbtn_pg_r_2.clicked.connect(
                lambda: self.carregaArquivos(self.dlg_exc_rain.le_2_pg_ri, 0, file_type='text'))
            self.dlg_exc_rain.tbtn_pg_r_3.clicked.connect(
                lambda: self.carregaArquivos(self.dlg_exc_rain.le_3_pg_ri, 0, file_type='text'))
            self.dlg_exc_rain.tbtn_pg_r_4.clicked.connect(
                lambda: self.save_buttons(self.dlg_exc_rain.le_4_pg_ri, file_type='text'))
            self.dlg_exc_rain.tbtn_pg_r_5.clicked.connect(
                lambda: self.selciona_pasta(self.dlg_exc_rain.le_5_pg_ri))
            self.dlg_exc_rain.btn_save_1_pg_ri.clicked.connect(
                lambda: self.CondicaoRunRainfall_inter(0))
            self.dlg_exc_rain.btn_save_2_pg_ri.clicked.connect(
                lambda: self.CondicaoRunRainfall_inter(1))

            '''Configura os botões da página da rotina flow routing'''
            # Configura botões das páginas da flow routing assim como a função de mudança de estilo
            self.dlg_flow_rout.btn_config.clicked.connect(
                lambda: self.SsButoes(self.dlg_flow_rout.btn_config, self.dlg_flow_rout))
            self.dlg_flow_rout.btn_config.clicked.connect(
                lambda: self.dlg_flow_rout.pages_flow_rout.setCurrentWidget(self.dlg_flow_rout.pg1_config))

            self.dlg_flow_rout.btn_input_data.clicked.connect(
                lambda: self.SsButoes(self.dlg_flow_rout.btn_input_data, self.dlg_flow_rout))
            self.dlg_flow_rout.btn_input_data.clicked.connect(
                lambda: self.dlg_flow_rout.pages_flow_rout.setCurrentWidget(self.dlg_flow_rout.pg2_in_data))

            self.dlg_flow_rout.btn_data_va_tool.clicked.connect(
                lambda: self.SsButoes(self.dlg_flow_rout.btn_data_va_tool, self.dlg_flow_rout))
            self.dlg_flow_rout.btn_data_va_tool.clicked.connect(
                lambda: self.dlg_flow_rout.pages_flow_rout.setCurrentWidget(self.dlg_flow_rout.pg3_data_val_tool))

            self.dlg_flow_rout.btn_run.clicked.connect(
                lambda: self.SsButoes(self.dlg_flow_rout.btn_run, self.dlg_flow_rout))
            self.dlg_flow_rout.btn_run.clicked.connect(
                lambda: self.dlg_flow_rout.pages_flow_rout.setCurrentWidget(self.dlg_flow_rout.pg4_run))

            # Configura botões da página de configuration: flow routing
            self.dlg_flow_rout.tbtn_pg1_1.clicked.connect(
                lambda: self.carrega_work_folder(self.dlg_flow_rout.le_3_pg1))

            # Configura os botões da página input data : flow routing
            self.dlg_flow_rout.tbtn_pg2_1.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_rout.cb_1_pg2))
            # self.dlg_flow_rout.tbtn_pg2_2.clicked.connect(
            #     lambda: self.carregaArquivos(0, self.dlg_flow_rout.cb_2_pg2))
            self.dlg_flow_rout.tbtn_pg2_3.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_rout.cb_3_pg2))
            self.dlg_flow_rout.tbtn_pg2_4.clicked.connect(
                lambda: self.carregaArquivos(self.dlg_flow_rout.le_4_pg2, 0, file_type='text'))
            self.dlg_flow_rout.tbtn_pg2_5.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_rout.cb_5_pg2))
            self.dlg_flow_rout.tbtn_pg2_6.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_rout.cb_4_pg2))

            self.dlg_flow_rout.tbtn_pg4_7.clicked.connect(
                lambda: self.carregaArquivos(self.dlg_flow_rout.le_7_pg4, 0, file_type='text'))
            
            # pedro
            self.dlg_flow_rout.pbtn_1_pg3.clicked.connect(
                 lambda: self.verificar_dimensoes_rasters(
                     paths=[
                        self.dlg_flow_rout.cb_1_pg2.currentText(),
                        self.dlg_flow_rout.cb_3_pg2.currentText(),
                        self.dlg_flow_rout.cb_5_pg2.currentText(),
                         
                     ], modulo=3
                 )
             )
            self.dlg_flow_rout.pbtn_2_pg3.clicked.connect(
                lambda: self.validar_raster_bacia(self.dlg_flow_rout.cb_1_pg2.currentText(),modulo=3)
            )
            self.dlg_flow_rout.pbtn_3_pg3.clicked.connect(self.verificar_tempos_de_viagem)

            # configura botões de salvar e salvar para um arquivo: flow travel time
            self.dlg_flow_rout.btn_save_file_pg1.clicked.connect(
                lambda: self.dlg_save_project_flow_rout.show())
            self.dlg_flow_rout.btn_save_file_pg2.clicked.connect(
                lambda: self.dlg_save_project_flow_rout.show())
            self.dlg_flow_rout.btn_save_file_pg4.clicked.connect(
                lambda: self.dlg_save_project_flow_rout.show())

            # configura gui save to project para criar projeto da excess rainfall
            self.dlg_save_project_flow_rout.tbtn_path.clicked.connect(
                lambda: self.get_project_dir(self.dlg_save_project_flow_rout))
            self.dlg_save_project_flow_rout.btn_save_project.clicked.connect(
                lambda: self.run_save_project(self.dlg_save_project_flow_rout, 3))

            # Configura botão para ler informações de uma arquivo enviado : flow routing
            self.dlg_flow_rout.btn_read_pg1.clicked.connect(
                lambda: self.read_from_project(3, self.dlg_flow_rout.le_3_pg1.text()))
            self.dlg_flow_rout.btn_read_pg2.clicked.connect(
                lambda: self.read_from_project(3, self.dlg_flow_rout.le_3_pg1.text()))
            self.dlg_flow_rout.btn_read_pg4.clicked.connect(
                lambda: self.read_from_project(3, self.dlg_flow_rout.le_3_pg1.text()))

            # Configura os botões da página run page: flow routing
            self.dlg_flow_rout.tbtn_pg4_1.clicked.connect(
                lambda: self.save_buttons(self.dlg_flow_rout.le_1_pg4))
            self.dlg_flow_rout.tbtn_pg4_2.clicked.connect(
                lambda: self.save_buttons(self.dlg_flow_rout.le_2_pg4))
            self.dlg_flow_rout.tbtn_pg4_3.clicked.connect(
                lambda: self.save_buttons(self.dlg_flow_rout.le_3_pg4))
            self.dlg_flow_rout.tbtn_pg4_4.clicked.connect(
                lambda: self.save_buttons(self.dlg_flow_rout.le_4_pg4))
            self.dlg_flow_rout.tbtn_pg4_5.clicked.connect(
                lambda: self.save_buttons(self.dlg_flow_rout.le_5_pg4))
            self.dlg_flow_rout.tbtn_pg4_6.clicked.connect(
                lambda: self.save_buttons(self.dlg_flow_rout.le_6_pg4, file_type='text'))

            # Atualiza status dos campos da vazão observada
            self.dlg_flow_rout.ch_12_pg4.stateChanged.connect(
                lambda: self.atualizaVazaoObs())

            # configura botões da página run : flow routing
            # Configura condição para chamar rotinas em vb
            self.dlg_flow_rout.btn_run_2.clicked.connect(
                lambda: self.condicaoRunFlowRouting())

            self.dlg_flow_rout.btn_close_pg4.clicked.connect(
                lambda: self.close_gui(3))

            '''Menu Hidropixel Plugin'''
            # Elimina os arquivos criados durante a execução do hidropixel
            self.apaga_arquivos_temp()

            # Run the dialog event loop
            self.dlg_hidro_pixel.exec_()

            # Será aplicado a lógica do botão save

            # Recarrega o plugin
            # qgis.utils.unloadPlugin('hidropixel')
            # qgis.utils.loadPlugin('hidropixel')
            qgis.utils.reloadPlugin('hidropixel')
            self.dlg_flow_tt.close()
            self.dlg_exc_rain.close()
            self.dlg_flow_rout.close()
            self.dlg_save_project_flow_tt.close()
            self.dlg_save_project_exc_rain.close()
            self.dlg_save_project_flow_rout.close()
            self.dlg_rain_interpl_run.close()
            self.dlg_about.close()
